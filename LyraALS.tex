\documentclass[10pt,CJKmath]{zhbook-v1}
%\xeCJKsetup{CJKmath=true}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,shapes.geometric,positioning,shadows,fit,backgrounds}
% Global TikZ styles for consistent, polished diagrams
\tikzset{
  base/.style={font=\small, align=center,inner sep=2pt,outer sep=0mm},
  block/.style={rectangle, draw=black!60, rounded corners, minimum width=20mm, minimum height=8mm, align=center, fill=teal!6, drop shadow, base},
  proc/.style={rectangle, draw=black!60, minimum width=38mm, minimum height=8mm, align=center, fill=orange!6, drop shadow, base},
  box/.style={rectangle, draw=black!45, rounded corners, minimum width=40mm, minimum height=8mm, align=center, fill=gray!6, base},
  arrow/.style={-{Latex[length=3mm]}, very thick, line cap=round, color=black!70}
}

\usepackage{fontawesome5}
\setmintedinline[c++]{breaklines,breakanywhere,bgcolor=none,breakanywheresymbolpre=\rotatebox{-90}{\mbox{\tiny\textcolor{pink}{\faLevelDown*}}}}
\newcommand{\il}[1]{\mintinline{c++}{#1}}%

\newtcbox{\mybox}[1][red]{on line,colupper=black,fonttitle=\bfseries,
 arc=4pt,outer arc=4pt,colback=yellow!10!white,colframe=#1!50!black,
 boxsep=0pt,left=2pt,right=2pt,top=1pt,bottom=1pt,
 boxrule=1pt,leftrule=1pt,rightrule=1pt}
 
 
\begin{document}
		%\frontmatter
    %\tableofcontents

\mainmatter
\pagestyle{fancy}
%\setchapterimage{./images/background}

\chapter{启始}
\section{NativeThreadSafeUpdateAnimation VS FAnimInstanceProxy}
对于需要大量计算的动画实例，并希望利用多线程进行求值，推荐使用 \il{FAnimInstanceProxy}。

这两者并非完全互斥的选项，\il{FAnimInstanceProxy} 是实现动画多线程更新的底层结构和推荐模式，而 \il{NativeThreadSafeUpdateAnimation} 是一个更上层的、简化的接口。

\begin{itemize}
	\item 重载 \il{NativeThreadSafeUpdateAnimation}：这是一种更简单直接的方法，适用于逻辑不那么复杂的场景。
			\begin{itemize}
			\item 优点:
			    \begin{itemize}
			    	\item 简单: 只需在 UAnimInstance 子类中重载一个函数，无需创建和管理额外的代理（Proxy）结构体。
			    	\item 快速实现: 对于简单的属性复制和计算，这种方式的代码量更少，更容易理解。
			    \end{itemize}
			
			\item 缺点:
				\begin{itemize}
						\item 功能限制: 它\textbf{本质}上是 \il{FAnimInstanceProxy::Update} 的一个简化包装。所有数据\dfntxt{必须是线程安全}的，并且必须在 NativeUpdateAnimation（游戏线程）中提前准备好，然后在这个函数（工作线程）中使用。
						\item 扩展性差: 随着计算逻辑变得越来越复杂（例如，需要缓存中间结果、跨帧数据等），只使用这个函数会变得混乱。所有逻辑和数据都挤在 UAnimInstance 类中，不符合关注点分离原则。
				\end{itemize}
			\end{itemize}
	\item  使用 \il{FAnimInstanceProxy}：这是UE官方推荐的、更健壮和可扩展的多线程动画更新模式。

	\begin{itemize}
		\item 	优点:
			\begin{itemize}
			\item 结构清晰: 强制将数据和逻辑分离。UAnimInstance 负责从游戏世界（Game Thread）收集数据，\il{FAnimInstanceProxy} 负责在工作线程（Worker Thread）上使用这些数据进行计算。
	    \item 性能更佳: 代理（Proxy）是一个普通的C++结构体（struct），比 UObject 更轻量。在工作线程上传递和操作代理的开销更小。
	    \item 扩展性强: 面对“未来会有大量的求值计算”，\il{FAnimInstanceProxy} 提供了清晰的扩展路径。你可以：
			\item 在 FAnimInstanceProxy::PreUpdate (Game Thread) 中高效地从 UAnimInstance 拷贝数据。
	    \item 在 FAnimInstanceProxy::Update (Worker Thread) 中执行所有复杂的计算。
	    \item 在 FAnimInstanceProxy::PostUpdate (Game Thread) 中将计算结果写回 UAnimInstance（如果需要）。
	    \item 更安全: 这种模式强制你思考线程安全问题，将游戏线程的访问和工作线程的计算明确分开，减少了多线程编程中常见的错误。
			\end{itemize}
	
		\item  缺点:	    更复杂: 需要额外定义一个 \il{FAnimInstanceProxy} 结构体，并重载 CreateProxy 和 DestroyProxy 函数。初始设置的代码量比仅重载 \il{NativeThreadSafeUpdateAnimation} 要多。
	\end{itemize}
\end{itemize}

\subsection{示例}
这是一个基于 ULyraBaseAnimInstance 的简洁示例，展示了如何实现 FAnimInstanceProxy 模式。这个例子遵循了UE官方推荐的最佳实践。

我们将为 ULyraBaseAnimInstance 创建一个代理 FLyraBaseAnimInstanceProxy，并在其中执行多线程计算。

\subsubsection{头文件 (LyraBaseAnimInstance.h)}

在头文件中，我们需要：
\begin{enumerate}
\item 声明代理结构体 FLyraBaseAnimInstanceProxy。
\item  在 ULyraBaseAnimInstance 中重载 CreateProxy 和 DestroyProxy。
\item  添加一些我们希望在工作线程中计算的属性，例如 GroundSpeed。
\item  定义 FLyraBaseAnimInstanceProxy 结构体，它继承自 FAnimInstanceProxy，并包含用于计算的成员变量和函数。
\end{enumerate}

\begin{amzcode}{c++}
// LyraBaseAnimInstance.h
// 1. 定义代理结构体，它将包含所有线程安全的数据和求值逻辑
USTRUCT()
struct FLyraBaseAnimInstanceProxy : public FAnimInstanceProxy
{
	GENERATED_BODY()

public:
	// 使用AnimInstance来初始化代理
	FLyraBaseAnimInstanceProxy(UAnimInstance* Instance);

	// 在工作线程上执行的更新函数，所有耗时计算都在这里
	virtual void Update(float DeltaSeconds) override;

	// 在游戏线程上，从AnimInstance拷贝数据到Proxy中
	virtual void PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds) override;

public:
	// 在工作线程上计算出的最终值
	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Proxy Data")
	float GroundSpeed = 0.0f;

	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Proxy Data")
	bool bIsFalling = false;

protected:
	// 从游戏线程拷贝过来的原始数据
	FVector CharacterVelocity;
	// ... 其他需要从游戏线程拷贝的数据
};


UCLASS(Abstract)
class LYRAALS_API ULyraBaseAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	ULyraBaseAnimInstance();

	// 在动画蓝图中可以直接使用的属性，由Proxy计算后更新
	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Movement")
	float GroundSpeed;

	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Movement")
	bool bIsFalling;

protected:
	// 2. 重载CreateProxy和DestroyProxy来创建和销毁我们的代理实例
	virtual FAnimInstanceProxy* CreateProxy() override;
	virtual void DestroyProxy(FAnimInstanceProxy* InProxy) override;

	// NativeUpdateAnimation现在非常轻量，主要用于数据同步
	virtual void NativeUpdateAnimation(float DeltaSeconds) override;

	virtual void NativeInitializeAnimation() override;

protected:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Global Variables")
	TWeakObjectPtr<ALyraCharacter> LyraCharacter;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Global Variables")
	TWeakObjectPtr<UCharacterMovementComponent> CharacterMovement;

private:
	// 动画实例的代理。这是UAnimInstance和其Proxy之间的桥梁。
	UPROPERTY(Transient)
	FLyraBaseAnimInstanceProxy Proxy;
};
\end{amzcode}

\subsubsection{源文件 (LyraBaseAnimInstance.cpp)}

在源文件中，我们实现各个函数的具体逻辑。
\begin{itemize}
\item \il{PreUpdate} (游戏线程): 从角色和移动组件获取数据，并将其存储在代理的成员变量中。
\item \il{Update} (工作线程): 使用代理中已存储的数据进行计算。\textbf{绝不}在此处访问任何\il{UObject}（如LyraCharacter）。
\item \il{NativeUpdateAnimation} (游戏线程): 将代理计算完成的结果拷贝回动画实例的属性，以便动画蓝图使用。
\end{itemize}

\begin{amzcode}{c++}
// LyraBaseAnimInstance.cpp
// --- Proxy Implementation ---

FLyraBaseAnimInstanceProxy::FLyraBaseAnimInstanceProxy(UAnimInstance* Instance)
	: FAnimInstanceProxy(Instance)
{
}

void FLyraBaseAnimInstanceProxy::PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds)
{
	// 在游戏线程执行：从动画实例和其拥有的对象（Actor等）安全地拷贝数据
	Super::PreUpdate(InAnimInstance, DeltaSeconds);

	ULyraBaseAnimInstance* LyraAnimInstance = Cast<ULyraBaseAnimInstance>(InAnimInstance);
	if (LyraAnimInstance && LyraAnimInstance->CharacterMovement.IsValid())
	{
		// 将需要的数据从游戏线程对象拷贝到代理的成员变量中
		CharacterVelocity = LyraAnimInstance->CharacterMovement->Velocity;
		bIsFalling = LyraAnimInstance->CharacterMovement->IsFalling();
		// ... 在这里拷贝所有其他需要的数据
	}
}

void FLyraBaseAnimInstanceProxy::Update(float DeltaSeconds)
{
	// 在工作线程执行：使用拷贝过来的数据进行所有耗时计算
	// 注意：这里绝对不能访问任何UObject指针（如LyraCharacter或CharacterMovement）
	Super::Update(DeltaSeconds);

	// 计算水平速度
	GroundSpeed = FVector(CharacterVelocity.X, CharacterVelocity.Y, 0.0f).Size();

	// ... 在这里执行所有其他的复杂计算
}


// --- AnimInstance Implementation ---

ULyraBaseAnimInstance::ULyraBaseAnimInstance()
{
	// 确保启用了多线程更新。如果动画蓝图的设置中未勾选，这行代码会强制开启。
	bUseMultiThreadedAnimationUpdate = true;
}

void ULyraBaseAnimInstance::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();
	if (AActor* OwningActor = GetOwningActor())
	{
		LyraCharacter = Cast<ALyraCharacter>(OwningActor);
		CharacterMovement = LyraCharacter.IsValid() ? LyraCharacter->GetCharacterMovement() : nullptr;
	}
}

FAnimInstanceProxy* ULyraBaseAnimInstance::CreateProxy()
{
	// 创建代理实例
	return new FLyraBaseAnimInstanceProxy(this);
}

void ULyraBaseAnimInstance::DestroyProxy(FAnimInstanceProxy* InProxy)
{
	// 销毁代理实例
	delete InProxy;
}

void ULyraBaseAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	// 在游戏线程执行：从代理获取计算结果，更新到动画实例的属性上
	// 这样动画蓝图就可以使用这些最新的值
	GroundSpeed = Proxy.GetGroundSpeed();
	bIsFalling = Proxy.GetIsFalling();
}
\end{amzcode}

这个模式的核心思想是 **数据分离**:

1.  **游戏线程 (Game Thread)**: PreUpdate 负责从游戏世界收集原始数据（如速度、状态）。
2.  **工作线程 (Worker Thread)**: Update 接收这些拷贝好的、线程安全的数据，并执行所有复杂的计算。
3.  **游戏线程 (Game Thread)**: NativeUpdateAnimation (或 PostUpdate) 将计算结果同步回 UAnimInstance，供动画蓝图使用。

这种方式结构清晰，性能和扩展性都非常出色，完全能够满足您未来大量计算的需求。
\subsection{github copilot示例及解决方案}
\paragraph{要点：}
动画蓝图不直接访问 Proxy。把要用到的值声明成 UAnimInstance 的 \il{UPROPERTY(BlueprintReadOnly)}，动画图会自动用到其在 Proxy 中的线程安全拷贝。

C++在 \il{NativeUpdateAnimation} 里计算并写入这些 UPROPERTY；Proxy 在 \il{PreUpdate} 把它们拷到线程安全字段给并行评估用。

如需在蓝图事件图读取“并行阶段的快照”，提供一个 BlueprintPure Getter，从游戏线程读取自定义 Proxy 的缓存。
在动画蓝图中使用方式：
在 ABP 的变量面板直接拖拽 Speed（或你的任意 UPROPERTY）进 AnimGraph，用于 BlendSpace、State Machine 条件等。
如果要读线程快照，调用 \il{GetSpeedTS_Snapshot} 蓝图函数节点。
下面示例添加一个 Speed 变量，并让 Proxy 在并行阶段使用其快照，同时提供一个蓝图 Getter 读取快照。

代理实现：
\begin{amzcode}{cpp}
#pragma once

#include "Animation/AnimInstanceProxy.h"

class ULyraBaseAnimInstance;

// 自定义 Proxy：仅存跨线程快照
struct FLyraBaseAnimInstanceProxy final : public FAnimInstanceProxy
{
	FLyraBaseAnimInstanceProxy() : FAnimInstanceProxy() {}
	explicit FLyraBaseAnimInstanceProxy(UAnimInstance* InInstance) : FAnimInstanceProxy(InInstance) {}

	// 线程安全快照(TS = Thread Safe)
	float SpeedTS = 0.f;

	virtual void PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds) override;
};
\end{amzcode}
\begin{amzcode}{cpp}
#include "AnimInst/LyraBaseAnimInstanceProxy.h"
#include "AnimInst/LyraBaseAnimInstance.h"

void FLyraBaseAnimInstanceProxy::PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds)
{
	FAnimInstanceProxy::PreUpdate(InAnimInstance, DeltaSeconds);

	if (const auto* Inst = Cast<ULyraBaseAnimInstance>(InAnimInstance))
	{
		SpeedTS = Inst->GetSpeed(); // 从实例拷贝到线程安全字段
	}
}
\end{amzcode}
动画实例的实现：
\begin{amzcode}{cpp}
UCLASS(Transient, Blueprintable, Abstract)
class LYRAALS_API ULyraBaseAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	ULyraBaseAnimInstance() = default;

	virtual void NativeInitializeAnimation() override;
	virtual void NativeUpdateAnimation(float DeltaSeconds) override;

	// 供 Proxy 读取，也可在 C++/蓝图读取（动画图会自动使用它的代理镜像）
	UFUNCTION(BlueprintPure, Category="Lyra|Movement")
	float GetSpeed() const { return Speed; }

	// 可选：蓝图读取并行快照（仅在游戏线程调用）
	UFUNCTION(BlueprintPure, Category="Lyra|Movement")
	float GetSpeedTS_Snapshot() const;

protected:
	// 动画蓝图直接使用这个变量（出现在变量面板，可接到 BlendSpace/条件等）
	UPROPERTY(Transient, BlueprintReadOnly, Category="Lyra|Movement", meta=(AllowPrivateAccess="true"))
	float Speed = 0.f;

	// 工程已有的弱引用
	UPROPERTY(Transient, BlueprintReadOnly, Category="Lyra|Global Variables")
	TWeakObjectPtr<ALyraCharacter> LyraCharacter;

	UPROPERTY(Transient, BlueprintReadOnly, Category="Lyra|Global Variables")
	TWeakObjectPtr<UCharacterMovementComponent> CharacterMovement;

	// 接入自定义 Proxy
	virtual FAnimInstanceProxy* CreateAnimInstanceProxy() override;
	virtual void DestroyAnimInstanceProxy(FAnimInstanceProxy* InProxy) override;
};
\end{amzcode}
实现：
\begin{amzcode}{cpp}
void ULyraBaseAnimInstance::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();

	LyraCharacter = Cast<ALyraCharacter>(TryGetPawnOwner());
	if (LyraCharacter.IsValid())
	{
		CharacterMovement = LyraCharacter->GetCharacterMovement();
	}
}

void ULyraBaseAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	// 运行时可能重新获取
	if (!LyraCharacter.IsValid())
	{
		LyraCharacter = Cast<ALyraCharacter>(TryGetPawnOwner());
		if (LyraCharacter.IsValid())
		{
			CharacterMovement = LyraCharacter->GetCharacterMovement();
		}
	}

	// 计算给动画图使用的值（游戏线程）
	Speed = CharacterMovement.IsValid() ? CharacterMovement->Velocity.Size() : 0.f;
}

FAnimInstanceProxy* ULyraBaseAnimInstance::CreateAnimInstanceProxy()
{
	return new FLyraBaseAnimInstanceProxy(this);
}

void ULyraBaseAnimInstance::DestroyAnimInstanceProxy(FAnimInstanceProxy* InProxy)
{
	delete static_cast<FLyraBaseAnimInstanceProxy*>(InProxy);
}

float ULyraBaseAnimInstance::GetSpeedTS_Snapshot() const
{
	const auto& P = GetProxyOnGameThread<FLyraBaseAnimInstanceProxy>();
	return P.SpeedTS;
}
\end{amzcode}
\subsection{结论}

考虑到您“预计未来会有大量的求值计算”，强烈建议从一开始就使用 \il{FAnimInstanceProxy} 模式。

虽然初始设置稍微复杂，但它提供的清晰结构、高性能和强大的扩展性，将为项目未来的维护和性能优化带来巨大好处，完全符合您的长远需求。只重载 \il{NativeThreadSafeUpdateAnimation} 是一种捷径，但对于复杂系统而言，它很快会成为技术债务。

\section{Animation Layer Interfaces 概述}

Animation Layer Interfaces（简称 ALI）是组织和复用动画层一种结构。在动画蓝图的事件图中，一团代码可以折叠成函数，从而达到复用/变量化的目的。然而，对于动画结点却不可以，\il{ALI}主要是为了解决这个问题而设计的。当然，如果不使用这种方式，也可以达到同样的目的：例如，在\il{UAnimInstance}派生类中设计一些动画序列变量，然后在运行时，根据某个状态来更改，但系统提供了更健壮、更灵活的开箱即用的产品，没理由不使用。

\begin{itemize}
  \item 目标：创建一个 Animation Layer Interface，在其中定义一个或多个 Animation Layers（例如 Idle Layer），并在动画蓝图中使用这些层以实现模块化动画逻辑。
  \item 创建流程（简要）：
    \begin{enumerate}
      \item 在 Content 目录中右键 → Animation → Animation Layer Interface，创建一个接口（示例命名为 \il{ALI_Lyra}）。
      \item 在接口内添加动画层（例如添加 Idle Layer）；该层通常不需要输入参数，仅有输出。
      \item 在目标 Animation Blueprint（如 \il{ABP_Base}）中打开 Class Settings，添加并实现该接口（添加 \il{ALI_Lyra}）。
      \item 将生成的 Idle Layer 拖入 Anim Graph 并连接；具体层的实现可以粘贴或复用现有的 Blend Poses（例如枪械的 Blend Poses）来快速测试。
    \end{enumerate}
  \item 推荐架构：
    \begin{itemize}
      \item 虽然可以直接在 ABP\_Base 中实现这些层并运行，但更优的做法是把具体层的实现放到另一个专门的 Animation Blueprint（例如 ABP\_Layers）中。
      \item ABP\_Base 负责主 Anim Graph，并通过实现的接口调用 ABP\_Layers 中的各个 layer，从而实现更好的模块化、可维护性和复用性。
    \end{itemize}
  \item 作用与背景：该方法被 ALS v4 以及 Lyra 的高级 locomotion 等项目采用，便于把动画层拆分为可重用的模块。
  \item 备注：视频演示中演示了将 Blend Poses 直接粘贴到层中以测试功能，但讲师建议采用分离层实现的方式，后续视频会进一步解释和展示该方法的优点。
\end{itemize}



\section{Link Anim Class 详述}

本视频讲解如何使用独立的 Animation Blueprint（下称 ABP\_Layers）来承载动画层，并在角色蓝图中通过 "Link Anim Class Layers" 节点将这些层替换到主动画蓝图（ABP\_Base）中，实现模块化与复用。详细内容分点说明如下：

\subsection{设计目标与总体思路}
\begin{itemize}
  \item 将与\emph{动画层}（Animation Layers）相关的内容从主动画蓝图（ABP\_Base）拆分出来，放入专门的动画蓝图（ABP\_Layers），以提升清晰度、优化与易扩展性。
  \item 在 ABP\_Base 中保留与动画计算相关的逻辑（例如速度、其他数值计算）与主 Anim Graph，而把具体的 layer 实现交给 ABP\_Layers。
  \item 在角色类（Character Class）的生命周期中（例如 EventBeginPlay），调用 LinkAnimClassLayers 将 ABP\_Base 中的占位层替换为 ABP\_Layers 中实现的层，从而在运行时“接入”具体层的动画输出。
\end{itemize}

\subsection{创建 ABP\_Layers（步骤）}
\begin{enumerate}
  \item 在 Content Drawer 中进入 ALS/Animation Blueprints，右键 → Animation Blueprint，创建一个新的动画蓝图，命名为 \texttt{ABP\_Layers}。
  \item 打开 \texttt{ABP\_Layers}，进入 Class Settings，点击 Implement Interfaces，然后添加之前创建的 Animation Layer Interface（如 ALI\_Lyra）。这样 \texttt{ABP\_Layers} 就包含了接口中定义的各个 layer。
  \item 注意：因为 \texttt{ABP\_Layers} 仅作为 layer 的容器，它的 Anim Graph 不需要输出最终姿势（不作为主输出），因此可以不维护 Event Graph 或其它不必要的部分。
\end{enumerate}

\subsection{在 ABP\_Layers 中实现 Idle Layer（示例实现）}
\begin{enumerate}
  \item 在 Idle Layer 的 Anim Graph 内，添加一个 Sequence Player 结点用于播放静止动画序列。
  \item 将 Sequence Player 的动画资源暴露为一个变量（将 Sequence Player 的动画 pin 提升为变量），命名为 \texttt{IdleAnim}，以便从外部（或编辑器）为该层设置不同的动画资产。
  \item 在示例中，将 \texttt{IdleAnim} 指向一个无武装（unarmed）的 idle 动画，编译以保存设置。注意：仅设置变量并不会立即在角色上显示效果，需完成链接流程。
\end{enumerate}

\subsection{在角色类中链接层（Link Anim Class Layers）}
\begin{itemize}
  \item 在角色类（Character Class）的 EventBeginPlay 中，获取角色的 Mesh（骨骼网格体），并调用节点 Link Anim Class Layers（或等价 API），将所创建的 \texttt{ABP\_Layers} 指定为要链接的动画蓝图层集合。
  \item 该节点的作用：在运行时将 ABP\_Base 中存在但未实现具体内容的所有动画层（占位层）替换为 \texttt{ABP\_Layers} 中实现的对应层，从而让角色使用这些具体层的动画（例如已设置的 unarmed idle）。
  \item 演示效果：链接后运行游戏，角色显示为无武装的 idle 状态；如果断开链接或不链接，则会回到原有占位姿势或无效果。
\end{itemize}

\subsection{关键要点与好处}
\begin{itemize}
  \item 模块化：将层拆分到单独蓝图后，可以独立开发、测试与复用（例如为武器、配件或特殊动作快速添加 layer）。
  \item 可配置性：通过在 ABP\_Layers 中使用公开变量（如 \texttt{IdleAnim}），可以在实例化或通过链接时灵活替换动画资产。
  \item 可扩展性：当需要添加新武器（如火箭发射器）或新动作时，只需在 ABP\_Layers 中新增 layer 并在角色中链接，无需修改 ABP\_Base 的核心计算逻辑。
  \item 性能与清晰性：把计算（速度、状态等）保留在 ABP\_Base，而把具体输出交给 ABP\_Layers，有助于代码/蓝图组织更清晰，且便于优化和多人协作。
\end{itemize}

\subsection{示例流程小结（按时序）}
\begin{enumerate}
  \item 在 Content 中创建 \texttt{ABP\_Layers}，并在 Class Settings 中实现 Animation Layer Interface（如 ALI\_Lyra）。
  \item 在 \texttt{ABP\_Layers} 中为每个 layer（示例：Idle Layer）实现动画逻辑，并将关键动画资源暴露为变量（例如 \texttt{IdleAnim}）。
  \item 在角色类的 EventBeginPlay 中调用 LinkAnimClassLayers，将 \texttt{ABP\_Layers} 链接到当前角色的 Anim Class Layers。
  \item 运行时，ABP\_Base 中的占位层将被替换为 \texttt{ABP\_Layers} 的实现，从而展现预期动画。
\end{enumerate}
\subsection{动画层级关系图}
% 使用 \resizebox{\linewidth}{!}{...} 以确保图形横向填满页面宽度
\resizebox{\linewidth}{!}{%
\begin{tikzpicture}[
  scale=0.95, % 内部微调比例（resizebox 已负责整体缩放）
  every node/.style={font=\small},
  node distance=10mm and 20mm,
  iface/.style={draw=blue!70, fill=blue!8, thick, rounded corners, align=center, minimum width=36mm},
  base/.style={draw=orange!75, fill=orange!8, thick, rounded corners, align=center, minimum width=36mm},
  layers/.style={draw=teal!70, fill=teal!8, thick, rounded corners, align=center, minimum width=36mm},
  layerexp/.style={draw=green!70, fill=green!12, thick, rounded corners, align=center, minimum width=30mm},
  collapsed/.style={draw=gray!40, fill=gray!6, rounded corners, align=center, minimum width=18mm, minimum height=6mm, font=\scriptsize},
  char/.style={draw=black!70, fill=black!6, thick, rounded corners, align=center, minimum width=36mm},
  linknode/.style={draw=red!70, fill=red!6, thick, rounded corners, align=center, minimum width=30mm},
  legendbox/.style={draw=black!40, fill=white, rounded corners, font=\footnotesize, inner sep=6pt},
  arrow/.style={-{Stealth[scale=1]}, thick},
  dashedarrow/.style={-{Stealth[scale=1]}, thick, dashed}
]

  % Top-level nodes
  \node[iface] (content) {Content / Interfaces};
  \node[below=of content, iface] (ali) {ALI\_Lyra\\(Animation Layer Interface)};

  % Middle: ABP_Base (left) and ABP_Layers (right)
  \node[below left=15mm and 20mm of ali, base] (abpbase) {ABP\_Base\\(主动画蓝图)\\占位 Layer};
  \node[below right=15mm and 20mm of ali, layers] (abplayers) {ABP\_Layers\\(Layer 容器)\\实现各层};

  % Layer implementations under ABP_Layers
  \node[below=of abplayers, layerexp] (idle) {Idle Layer\\Sequence Player\\\texttt{IdleAnim} (variable)};
  \node[right=12mm of idle, collapsed] (weapon) {...\\Weapon Layers};
  \node[left=12mm of idle, collapsed] (upperbody) {...\\UpperBody Layers};

  % Placeholder under ABP_Base
  \node[below=of abpbase, collapsed] (placeholder) {Idle Layer (占位)};

  % Character and link node (left side)
  \node[left=34mm of abpbase, char] (character) {Character Class\\EventBeginPlay};
  \node[below=of character, linknode] (link) {LinkAnimClassLayers};

  % Connections
  \draw[arrow] (content) -- (ali);
  \draw[arrow] (ali) -- (abpbase) node[midway, left, font=\small] {接口实现};
  \draw[arrow] (ali) -- (abplayers) node[midway, right, font=\small] {接口实现};

  \draw[arrow] (abplayers) -- (idle) node[midway, right, font=\small] {包含具体实现};
  \draw[arrow] (abplayers) -- (upperbody);
  \draw[arrow] (abplayers) -- (weapon);

  \draw[arrow] (abpbase) -- (placeholder) node[midway, left, font=\small] {占位层};

  \draw[arrow] (character) -- (link);
  \draw[dashedarrow] (link) to[bend left=20] node[midway, above, font=\small] {指定 \texttt{ABP\_Layers}} (abplayers);
  \draw[dashedarrow] (link) to[bend right=20] node[midway, above, font=\small] {替换 ABP\_Base 的层} (abpbase);

  % Legend placed above the note (under the figure)
  \node[legendbox, below=12mm of upperbody, anchor=north] (legend) {
    \begin{tabular}{@{}l@{\quad}l}
      \tikz \node[iface, minimum width=6mm, minimum height=4mm] {}; & Interface / Content \\
      \tikz \node[base, minimum width=6mm, minimum height=4mm] {}; & ABP\_Base (占位) \\
      \tikz \node[layers, minimum width=6mm, minimum height=4mm] {}; & ABP\_Layers (实现容器) \\
      \tikz \node[layerexp, minimum width=6mm, minimum height=4mm] {}; & 展开层（具体实现） \\
      \tikz \node[collapsed, minimum width=6mm, minimum height=4mm] {}; & 折叠/占位 层 \\
      \tikz \node[linknode, minimum width=6mm, minimum height=4mm] {}; & 运行时链接节点
    \end{tabular}
  };

  % EXAMPLE / NOTE moved to bottom (below legend)
  \node[draw=none, below=6mm of legend, align=left, font=\footnotesize] (note) {
    示例与说明：运行时调用 \texttt{LinkAnimClassLayers} 会将 \texttt{ABP\_Base} 中的占位层替换为 \texttt{ABP\_Layers} 中实现的对应层（例如 Idle Layer），从而使角色显示设定好的动画（如 unarmed idle）。图中绿色节点为具体实现，灰色为占位/折叠表示。
  };

\end{tikzpicture}%
} % end resizebox

\subsection{结语与后续内容}
本视频主要演示了如何把动画层作为独立容器并在运行时链接回主动画蓝图，从而获得模块化和复用的优势。作者在下一视频中将继续展示这些 ABP\_Layers 的更高级用法与亮点，建议继续观看以理解完整工作流与实战技巧。

\setchapterimage{./images/root.png}
\chapter{Root Motion}
\section{Root Motion 启用与否的差异}

\subsection{概念性差异}
\begin{itemize}
    \item \textbf{启用 Root Motion：} 动画资产携带根骨骼的位移和旋转。在动画评估时，引擎会提取这部分运动（即“根运动”），并用它来驱动 \texttt{Actor} 或角色的世界变换（如果 \texttt{AnimInstance} 的根运动模式允许）。动画本身会直接导致角色在游戏世界中移动。
    \item \textbf{未启用 Root Motion：} 动画通常是“在原地播放”（in-place），根骨骼不包含全局位移。角色的位置由 \texttt{CharacterMovementComponent} 或自定义代码逻辑驱动，动画只负责骨骼的相对姿态。
\end{itemize}

\subsection{主要注意事项}
\begin{itemize}
    \item \textbf{提取时机与设置：} 即使动画包含根运动数据，是否实际应用它取决于 \texttt{AnimInstance} 的 \texttt{Root Motion Mode} 设置（例如 \texttt{Root Motion from Everything} 或 \texttt{Root Motion from Montages Only}）。通常，将根运动放在 \texttt{AnimMontage} 中更容易控制其生效时机。

    \item \textbf{与 CharacterMovement 的协作：} 启用根运动时，通常由\textbf{动画驱动位移}，而 \il{CharacterMovementComponent} 则负责处理由该位移引发的碰撞、滑动和地面检测。混合使用原地动画和根运动动画时，必须明确哪个系统在何时负责位移。

    \item \textbf{网络复制：} 根运动的网络复制很复杂。默认情况下，网络移动基于 \texttt{CharacterMovementComponent} 的客户端预测和服务器修正。启用根运动时，需要依赖引擎内置的根运动复制机制或实现专门的服务器权威逻辑，否则极易出现客户端与服务器不同步的问题。

    \item \textbf{播放控制与蒙太奇：} 强烈建议将带有根运动的关键动作（如翻滚、特殊攻击）放在 \texttt{AnimMontage} 中。这便于精确控制根运动的开始、结束、同步，并且引擎对蒙太奇的根运动支持更为明确和健壮。

    \item \textbf{骨骼与资源制作：} 确保根骨骼是正确的，并且位移信息已烘焙到根骨骼上。注意，动画重定向（Retargeting）过程可能会改变或丢失根运动数据。不要将位移信息放在加法（additive）动画层中。

    \item \textbf{混合和层级：} 混合多个带有根运动的动画会导致位移合成变得复杂且不可预测。通常应避免在多个动画层上同时启用完整的根运动。

    \item \textbf{Root Motion Root Lock / 原点策略：} 根据需要选择合适的根锁定选项（如 \texttt{Reference Pose}, \texttt{Anim First Frame}, \texttt{Zero}），这会影响姿态和旋转的参考点，从而影响角色最终的位置和朝向。

    \item \textbf{调试与测试：} 在编辑器中开启根运动可视化功能，检查实际提取的运动轨迹是否符合预期。在不同的网络条件、物理和碰撞设置下进行充分测试。

    \item \textbf{线程安全与评估：} 动画评估（包括根运动提取）可能在工作线程（动画代理线程）上执行。最终的位移应用会回到游戏线程。遵循代理模式：在游戏线程的 \texttt{PreUpdate} 中快照所需数据，在工作线程中计算，在游戏线程的 \texttt{PostUpdate} 中应用结果。
\end{itemize}

\subsection{何时使用}
\begin{itemize}
    \item \textbf{使用 Root Motion：} 适用于需要动画与位移精确同步的复杂动作，例如翻滚、跳跃、攀爬、特定的攻击位移等。
    \item \textbf{不使用 Root Motion：} 适用于常规的、由玩家输入控制的持续性移动，如行走、奔跑。将位移控制权交给 \texttt{CharacterMovementComponent} 更便于网络预测和物理交互。
\end{itemize}

\subsection{简短结论}
启用根运动会将位移的控制权“从动画赋予世界”，其管理较为复杂，但适用于动作驱动的移动。禁用根运动则将位移控制权交给代码（如 \texttt{CharacterMovementComponent}），更易于网络同步和物理预测。
\subsubsection{从动画赋予世界的解释}
这句话的意思是，当启用根运动时，角色在游戏世界中的实际位置移动，是由播放的动画文件本身来决定的，而不是由常规的角色移动代码（如 CharacterMovementComponent）来控制。
可以这样理解：
\begin{itemize}
\item 常规情况 (未启用根运动):
	\begin{enumerate}
		\item 控制权在代码/蓝图：你按下 W 键，CharacterMovementComponent 计算出角色应该向前移动，并更新其在世界中的位置。
		\item 动画只是“表演”：动画系统播放一个“原地行走”的动画来匹配这个移动。动画本身并没有让角色真的前进，它只是在原地摆动腿。位移是由代码驱动的。
	\end{enumerate}
\item 启用根运动后:
	\begin{enumerate}
	\item 控制权在动画文件：动画师在制作一个“前冲攻击”的动画时，已经让角色的根骨骼在动画中向前移动了1米。
	\item 动画“驱动”世界：当游戏播放这个动画时，引擎会提取出根骨骼移动1米的数据，并将其应用到角色在游戏世界中的实际位置上。角色真的向前移动了1米，因为动画文件就是这么设计的。
	\end{enumerate}
\end{itemize}	
所以，“从动画赋予世界”就是指，将动画文件（UAnimSequence）中包含的位移信息（“从动画”），直接应用为角色在游戏世界（“世界”）中的实际位置变化（“赋予”）。控制权从通用的移动代码转移到了特定的动画资产上。
\section{Force Root Lock 的作用}

\texttt{Force Root Lock} 是一个可以在动画序列(\texttt{AnimSequence})或动画蒙太奇(\texttt{AnimMontage})中设置的选项。其核心作用是：

\textbf{强制禁用根运动中的“平移”部分，但通常会保留“旋转”部分。}

\subsection{具体效果}
当勾选此选项时：
\begin{itemize}
    \item \textbf{阻止位移：} 即使动画文件本身包含让角色向前、向后或侧向移动的根运动数据，角色的碰撞体（Capsule）也不会在世界中发生实际的位置移动。角色在平移上被“锁定”在原地。
    \item \textbf{保留姿态和旋转：} 动画的姿态（骨骼如何弯曲）和根骨骼的旋转（角色朝向的变化）仍然会被应用。
\end{itemize}

\subsection{主要使用场景}
这个选项非常有用，主要用于以下情况：
\begin{itemize}
    \item \textbf{上半身动画蒙太奇：} 这是最常见的用法。想象一个角色正在奔跑（由 \texttt{CharacterMovementComponent} 控制移动），此时需要播放一个上半身的攻击或施法动画。这个攻击动画本身可能带有向前冲刺的根运动。
    \begin{itemize}
        \item \textbf{不使用 \texttt{Force Root Lock}：} 角色在奔跑的基础上，还会叠加攻击动画的根运动，导致一个不自然的、过快的“二次加速”前冲。
        \item \textbf{使用 \texttt{Force Root Lock}：} 角色的奔跑速度完全由 \texttt{CharacterMovementComponent} 控制。攻击蒙太奇播放时，只会应用其攻击的姿态和身体的扭转，而不会应用其向前冲刺的位移。这样看起来就像角色在保持奔跑速度的同时，完成了攻击动作。
    \end{itemize}

    \item \textbf{需要动画姿态但不需要位移的场合：} 你可能喜欢某个带根运动的动画（比如一个有力的挥拳动作），但希望角色在原地完成这个动作，而不是像动画数据显示的那样向前冲一步。勾选 \texttt{Force Root Lock} 就可以让你“借用”这个动画的姿态，而忽略它的位移。

    \item \textbf{平滑过渡：} 在从一个根运动动画过渡回一个“原地”（In-place）动画时，使用这个选项可以帮助防止角色位置在过渡瞬间发生跳变。
\end{itemize}

\subsection{与之前概念的联系}
回到“从动画赋予世界”这句话：
\begin{itemize}
    \item \textbf{常规根运动：} 是“动画”将它的“位移和旋转”赋予“世界”中的角色。
    \item \textbf{启用 \texttt{Force Root Lock}：} 你对引擎说：“这次动画只能把它的‘旋转和姿态’赋予世界，把‘位移’留下，位移由我（代码/\texttt{CharacterMovementComponent}）自己控制。”
\end{itemize}

因此，\texttt{Force Root Lock} 是一个强大的工具，它让你能更精细地控制根运动，决定是完全采用动画的运动数据，还是只采用其中的一部分。
\section{Additive Anim Type}
附加动画是一种可以加在正在播放的动画之上的动画。它类似于对动画进行偏移，譬如向右或向左偏移一点，对吧？这就是加成动画的作用。
\begin{itemize}
\item 目标与效果：为角色在向左/向右移动时添加轻微倾斜（lean），使行走与慢跑动作看起来更自然；行走已有一定效果，但慢跑需要增强。
\item 资源：使用视频提供的资源包 \texttt{61 Lean Animations}，包含三段用于步枪的倾斜动画（center / right / left）。这些动画只影响根骨骼与脊柱，不修改手部，因此可复用于手枪或空手姿势。
\item 导入步骤：
\begin{itemize}
\item 在 Unreal 的 Content 窗格中进入 \texttt{ALS} → \texttt{animations} → \texttt{rifle}（或目标文件夹）。
\item 新建子文件夹（例如 \texttt{lean}），将动画文件拖放进去。
\item 导入时选择骨架：\il{SK_Mannequin}，然后导入所有动画资产。
\end{itemize}
\item 设置为加成动画（Additive）：
\begin{itemize}
\item 对于中心动画（center）：在动画资产的 Additive 设置中将类型改为 Local Space，并将 Base Pose Type 设为 \texttt{Selected Animation Frame}，选择第 0 帧作为基准中心帧。
\item 对于左右动画（right / left）：同样设置 Additive Anim Type 为 Local Space，Base Pose 指向 center（Selected Animation Frame → center），以便基于中心姿势计算偏移。
\item 说明：Local Space 与 Mesh Space 对应不同的动画蓝图节点；使用哪种空间就配套使用相应节点。
\end{itemize}
\item 完成与应用：保存所有动画设置后，可使用 Blend Space 或动画合成节点将这些加成动画应用于行走/慢跑等播放逻辑中。
\item 命名参考：示例动画名如 \il{MMRifle jog lean center}；骨架示例为 \il{SK_Mannequin}。
\item 建议：保持加成动画仅修改根与脊柱，使用统一的中心基准帧可确保在不同武器或姿势间的一致性与可复用性。
\end{itemize}

\section{0062 — Lean Blend Space（混合空间）详细总结}

\subsection{概述}
本段字幕讲解如何在 Unreal Engine 中为角色实现“lean”（倾斜/侧倾）效果，采用 Blend Space（混合空间）来在动画蓝图中干净且高效地管理多个倾斜动作。主要内容包括创建 Blend Space 资产、设置网格（grid）和轴（axes）、添加并定位动画样本、使用预览调试、以及通过参数（如 gate）控制倾斜强度与平滑过渡。

\subsection{文件与资产位置}
\begin{itemize}
\item 在项目的 ALS 文件夹中创建一个新文件夹：\texttt{blend spaces}，用于存放 Blend Space 资产。
\item 创建 Blend Space（非 legacy 的 1D），在示例中命名为 \texttt{BS\_lean}，并选择角色使用的 Skeleton（例如 Escape mannequin）。
\end{itemize}

\subsection{Blend Space 网格与轴设置}
\begin{itemize}
\item 水平轴（horizontal axis）
\begin{itemize}
\item 名称：\texttt{lean angle}
\item 取值范围：(-90) 到 (90)（表示左右倾斜角度）
\item 网格分割（grid division）：水平方向设置为 2（两列）
\item 启用“snap to grid”，便于将动画样本对齐到网格点
\end{itemize}
\item 垂直轴（vertical axis）
\begin{itemize}
\item 名称：\texttt{gate}
\item 取值范围：0 到 1（表示影响倾斜强度的权重或“门”参数）
\item 网格分割：设置为 2（两行）
\item 同样启用“snap to grid”
\end{itemize}
\end{itemize}

\subsection{添加动画样本与布局策略}
\begin{itemize}
\item 在 Blend Space 中搜索并添加与 lean 相关的动画（如 \texttt{jog lean center}, \texttt{lean left}, \texttt{lean right} 等）。
\item 样本放置建议：
\begin{itemize}
\item 当 \texttt{lean angle} = 0（中心）时，放置 center 的动画（如 \texttt{jog lean center}）。
\item 当 \texttt{lean angle} = -90（极左）时，放置向左倾斜的动画（\texttt{lean left}）。
\item 当 \texttt{lean angle} = +90（极右）时，放置向右倾斜的动画（\texttt{lean right}）。
\end{itemize}
\item 保持样本布局清晰、对称会带来更好插值效果。
\end{itemize}

\subsection{预览与调试}
\begin{itemize}
\item 在 Blend Space 的预览（preview）中选择一个基准姿势（例如 \texttt{pistol jog forward}）来观察样本插值效果。
\item 通过在网格中移动预览点（按住 Ctrl 并拖动）可观察不同 \texttt{lean angle} 与 \texttt{gate} 组合下的视觉结果。
\item 常见问题：插值过快或过猛，视觉上显得突兀。
\end{itemize}

\subsection{平滑与移动时间（Moving Time）}
\begin{itemize}
\item 为避免动画切换瞬间完成（过快），调整 horizontal 和 vertical 轴的 Moving Time（移动时间），示例中将其从默认值改为 0.5 秒，使过渡更平滑。
\item 结果：当在预览点快速移动时，达到目标参数需要约 0.5 秒，减少突兀感。
\end{itemize}

\subsection{Gate 参数的作用（影响倾斜强度）}
\begin{itemize}
\item \texttt{gate} 的范围是 0..1，用于控制倾斜的“幅度”：
\begin{itemize}
\item \texttt{gate} = 1：完全按 \texttt{lean angle} 的值倾斜（例如角度接近 ±90 时表现为完全倾斜）。
\item \texttt{gate} = 0：不倾斜或最小倾斜。
\end{itemize}
\item 实际应用示例：行走（walking）时设置 gate 较小（譬如 0.2），跑步或慢跑（jogging）时将 gate 设置为更大，以产生更显著的倾斜效果。
\end{itemize}

\subsection{在动画蓝图中的使用与建议}
\begin{itemize}
\item 创建好 Blend Space 后，将其在 Animation Blueprint（ABP）或 ABP Layer 中作为混合数据源使用——这是将视觉效果整合入角色动画系统的推荐做法。
\item 推荐流程：
\begin{enumerate}
\item 在角色的运行时计算并输出 \texttt{lean angle}（根据移动方向、速度和角色朝向等）；
\item 计算并输出 \texttt{gate}（根据速度状态，如 walking/jogging/run、是否瞄准等）；
\item 将两参数传入 Blend Space，从而驱动动画插值。
\end{enumerate}
\item 注意事项与边界情况：
\begin{itemize}
\item 当角色从静止到移动、或方向突变时，配合合适的 Moving Time 可避免帧间抖动或瞬移。
\item 小范围 gate（如 0.1–0.3）适合步行，较大 gate 适合疾走/奔跑；根据动作设计与手感调参。
\item 保证动画样本在网格边界处能平滑过渡，必要时补充中间帧样本。
\end{itemize}
\end{itemize}

\subsection{总结要点（便于快速复现）}
\begin{itemize}
\item 在 ALS 项目下创建 \texttt{blend spaces} 文件夹并新建 Blend Space（例如 \texttt{BS\_lean}）。
\item Horizontal axis = \texttt{lean angle}, range = [-90, 90], divisions = 2。
\item Vertical axis = \texttt{gate}, range = [0, 1], divisions = 2。
\item 启用 snap-to-grid，按网格放置 center/left/right 动画样本。
\item 将 horizontal/vertical 的 Moving Time 设为 0.5 以平滑过渡。
\item 在 Animation Blueprint 中用运行时参数驱动 \texttt{lean angle} 和 \texttt{gate}，根据速度和动作状态调整 gate（例如 walking ≈ 0.2）。
\end{itemize}

\subsection{补充建议}
\begin{itemize}
\item 在蓝图或 C++ 中封装计算 \texttt{lean angle} 与 \texttt{gate} 的函数/模块，便于复用与调试。
\item 增加调试可视化（如在 HUD 或蓝图打印当前参数），能显著加快调整过程。
\item 若角色有不同武器姿态或动画层（aiming、crouch 等），考虑为不同状态分别使用或调整对应的 Blend Space 参数。
\end{itemize}



\section{0064 — Calculate Lean Angle（计算倾斜角）}

\subsection{总体目标}
本段字幕演示如何在 Animation Blueprint 的基础层（ABP Base / Rotation Data）中计算角色的 lean（侧倾）角度。思路是通过比较当前帧与上一帧的角色朝向（yaw）差值，换算为受时间归一化的角速度，然后限制与缩放该值以得到最终的 lean angle，最后将该值传递给动画系统（如 ABP Layers）以驱动视觉侧倾。

\subsection{输入与输出（契约）}
\begin{itemize}
\item 输入
\begin{itemize}
\item 当前帧角色的 World Rotation（只需 Yaw 分量）。
\item 上一帧保存的 Actor Yaw（从变量读取）。
\item Delta Time（帧时间，作为时间归一化因子）。
\end{itemize}
\item 输出
\begin{itemize}
\item lean angle（已 clamp 到 [-90, 90]，并可通过缩放参数放大或缩小）。
\item lean angle 将通过属性访问（Property Access）从 ABP Base 传给 ABP Layers。
\end{itemize}
\item 错误/边界模式：如果不做时间归一化或不 clamp，会得到非常大的数值或不稳定的结果（字幕中提到曾看到 ~200 的错误值）。
\end{itemize}

\subsection{实现步骤（Blueprint 细节）}
\begin{enumerate}
\item 在 ABP Base 或 Rotation Data 函数/节点中获取当前帧的 world rotation：
\begin{itemize}
\item 使用 Get World Rotation -> Break Rotator -> 只取 Yaw。
\item 将该 Yaw Promote 为变量（例如命名为 Actor Yaw）。
\end{itemize}
\item 保存“上一帧”的 yaw：
\begin{itemize}
\item 在设置当前帧 Actor Yaw 之前，先把现有的 Actor Yaw 复制并存入另一个变量（例如 Last Frame Actor Yaw）。
\item 这样在设置新值之前，变量 Last Frame Actor Yaw 存储的是上一帧的朝向。
\end{itemize}
\item 计算 delta yaw（帧间差）：
\begin{itemize}
\item 使用 Last Frame Actor Yaw 与当前 Actor Yaw 相减得到 Delta Actor Yaw（差值）。
\item 将其也 Promote 为变量（例如 Delta Actor Yaw），并保持执行流的连接。
\end{itemize}
\item 将“帧差”转为“时间归一化的角速度”：
\begin{itemize}
\item 用 Delta Actor Yaw 除以 Delta Time（或 Delta Seconds）来得到基于时间的变化率（避免依赖帧率）。
\item 该字幕建议从 Update Animation 的输入获取 Delta Time（在 Blueprint Thread 的 Update Animation 节点中已有 delta 的输入），因此可把 delta time 作为函数输入传入（清晰且整洁）。
\end{itemize}
\item 缩放并限制值（Clamp）：
\begin{itemize}
\item 若直接除以 delta time 得到的值过大，可再除以一个常数（例子中使用 6）或乘以一个缩放系数，得到合适的数值范围。
\item 使用 Clamp Angle，限制结果在 [-90, 90] 范围内，避免超过期望的倾斜范围。
\item 将最终值 Promote 为变量并命名为 Lean Angle，确保有执行针脚来设置该变量。
\end{itemize}
\item 将 Lean Angle 暴露给 ABP Layers：
\begin{itemize}
\item 在 ABP Layers 中通过 Property Access 获取 ABP Base 的 Lean Angle 并连接到相应 Blend Space/动画输入。
\item 在运行时观察效果，调整缩放系数（字幕示例中提到将值改为 5 可以增大倾斜量）。
\end{itemize}
\end{enumerate}

\subsection{调试与发现的问题}
\begin{itemize}
\item 初次调试时在输出日志中打印得到的值，发现未做时间归一化会得到非常大的数字（例如 ~200），因此必须用 Delta Time 做除法。
\item 为了方便调试，在 Update Animation（蓝图线程）中用 Log String（或 Print）查看中间数值，测试时可取消 debug 的一些编译选项以清晰观察日志。
\item 发现向后移动时（backward），当前计算出的 lean 方向相反（即朝向错误），这是下一个视频/步骤要修复的问题（字幕在结尾指出这一点，并将在后续演示修正方法）。
\end{itemize}

\subsection{参数与调节建议}
\begin{itemize}
\item delta time：必须使用以避免帧率依赖。
\item 缩放系数（示例：除以 6 或乘以某系数）：用于调节感受与灵敏度。推荐将其作为可调参数暴露在 ABP Base 或数据表中以便快速调整。
\item Clamp 范围：字幕示例用 [-90, 90]；根据 Blend Space 与动画设计，可以缩小该范围以获得更自然表现（例如 [-45, 45]）。
\item 在 ABP Layers 中可再叠加平滑（如插值或移动时间）来避免突变。
\end{itemize}

\subsection{常见边界情况与改进思路}
\begin{itemize}
\item 角色快速转头或鼠标大幅移动会产生较大的 yaw 差值，建议增加平滑器（例如 RInterp 或 FInterp 的蓝图/函数）或限制最大增量以防突兀。
\item 后退时倾斜方向错误：需要判断角色移动方向（forward/backward）与朝向的关系，可能需对 delta yaw 根据角色速度或移动向量作符号调整（在下一步/视频中会讲解）。
\item 不同状态下使用不同系数：例如站立/行走/奔跑/瞄准可以使用不同的缩放因子或 gate 值（结合前面讲的 Blend Space 的 gate 参数）。
\item 若多人服或网络同步：应在服务器/客户端同步或仅基于本地控制器输入计算以避免抖动与预测偏差。
\end{itemize}

\subsection{小结}
通过以下流程可以获得稳定且可调的 lean angle：
\begin{enumerate}
\item 在 ABP Base 获取并保存当前与上一帧的 yaw；
\item 计算帧间 yaw 差并用 delta time 归一化为角速度；
\item 经过缩放与 clamp 得到最终 lean angle；
\item 将 lean angle 暴露给 ABP Layers 的动画输入，配合 Blend Space 或动画图层驱动视觉倾斜；
\item 注意处理后退方向与快速旋转情形的特殊判定与平滑。
\end{enumerate}

\setchapterimage{}
\chapter{停止动画}
\end{document}
