\documentclass[10pt,CJKmath]{zhbook-v1}
%\xeCJKsetup{CJKmath=true}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,shapes.geometric,positioning,shadows,fit,backgrounds}
% Global TikZ styles for consistent, polished diagrams
\tikzset{
  base/.style={font=\small, align=center,inner sep=2pt,outer sep=0mm},
  block/.style={rectangle, draw=black!60, rounded corners, minimum width=20mm, minimum height=8mm, align=center, fill=teal!6, drop shadow, base},
  proc/.style={rectangle, draw=black!60, minimum width=38mm, minimum height=8mm, align=center, fill=orange!6, drop shadow, base},
  box/.style={rectangle, draw=black!45, rounded corners, minimum width=40mm, minimum height=8mm, align=center, fill=gray!6, base},
  arrow/.style={-{Latex[length=3mm]}, very thick, line cap=round, color=black!70}
}

\usepackage{fontawesome5}
\setmintedinline[c++]{breaklines,breakanywhere,bgcolor=none,breakanywheresymbolpre=\rotatebox{-90}{\mbox{\tiny\textcolor{pink}{\faLevelDown*}}}}
\newcommand{\il}[1]{\mintinline{c++}{#1}}%

\newtcbox{\mybox}[1][red]{on line,colupper=black,fonttitle=\bfseries,
 arc=4pt,outer arc=4pt,colback=yellow!10!white,colframe=#1!50!black,
 boxsep=0pt,left=2pt,right=2pt,top=1pt,bottom=1pt,
 boxrule=1pt,leftrule=1pt,rightrule=1pt}
 
 
\begin{document}
		%\frontmatter
    %\tableofcontents

\mainmatter
\pagestyle{fancy}
%\setchapterimage{./images/background}

\chapter{启始}
\section{NativeThreadSafeUpdateAnimation VS FAnimInstanceProxy}
对于需要大量计算的动画实例，并希望利用多线程进行求值，推荐使用 \il{FAnimInstanceProxy}。

这两者并非完全互斥的选项，\il{FAnimInstanceProxy} 是实现动画多线程更新的底层结构和推荐模式，而 \il{NativeThreadSafeUpdateAnimation} 是一个更上层的、简化的接口。

\begin{itemize}
	\item 重载 \il{NativeThreadSafeUpdateAnimation}：这是一种更简单直接的方法，适用于逻辑不那么复杂的场景。
			\begin{itemize}
			\item 优点:
			    \begin{itemize}
			    	\item 简单: 只需在 UAnimInstance 子类中重载一个函数，无需创建和管理额外的代理（Proxy）结构体。
			    	\item 快速实现: 对于简单的属性复制和计算，这种方式的代码量更少，更容易理解。
			    \end{itemize}
			
			\item 缺点:
				\begin{itemize}
						\item 功能限制: 它\textbf{本质}上是 \il{FAnimInstanceProxy::Update} 的一个简化包装。所有数据\dfntxt{必须是线程安全}的，并且必须在 NativeUpdateAnimation（游戏线程）中提前准备好，然后在这个函数（工作线程）中使用。
						\item 扩展性差: 随着计算逻辑变得越来越复杂（例如，需要缓存中间结果、跨帧数据等），只使用这个函数会变得混乱。所有逻辑和数据都挤在 UAnimInstance 类中，不符合关注点分离原则。
				\end{itemize}
			\end{itemize}
	\item  使用 \il{FAnimInstanceProxy}：这是UE官方推荐的、更健壮和可扩展的多线程动画更新模式。

	\begin{itemize}
		\item 	优点:
			\begin{itemize}
			\item 结构清晰: 强制将数据和逻辑分离。UAnimInstance 负责从游戏世界（Game Thread）收集数据，\il{FAnimInstanceProxy} 负责在工作线程（Worker Thread）上使用这些数据进行计算。
	    \item 性能更佳: 代理（Proxy）是一个普通的C++结构体（struct），比 UObject 更轻量。在工作线程上传递和操作代理的开销更小。
	    \item 扩展性强: 面对“未来会有大量的求值计算”，\il{FAnimInstanceProxy} 提供了清晰的扩展路径。你可以：
			\item 在 FAnimInstanceProxy::PreUpdate (Game Thread) 中高效地从 UAnimInstance 拷贝数据。
	    \item 在 FAnimInstanceProxy::Update (Worker Thread) 中执行所有复杂的计算。
	    \item 在 FAnimInstanceProxy::PostUpdate (Game Thread) 中将计算结果写回 UAnimInstance（如果需要）。
	    \item 更安全: 这种模式强制你思考线程安全问题，将游戏线程的访问和工作线程的计算明确分开，减少了多线程编程中常见的错误。
			\end{itemize}
	
		\item  缺点:	    更复杂: 需要额外定义一个 \il{FAnimInstanceProxy} 结构体，并重载 CreateProxy 和 DestroyProxy 函数。初始设置的代码量比仅重载 \il{NativeThreadSafeUpdateAnimation} 要多。
	\end{itemize}
\end{itemize}

\subsection{示例}
这是一个基于 ULyraBaseAnimInstance 的简洁示例，展示了如何实现 FAnimInstanceProxy 模式。这个例子遵循了UE官方推荐的最佳实践。

我们将为 ULyraBaseAnimInstance 创建一个代理 FLyraBaseAnimInstanceProxy，并在其中执行多线程计算。

\subsubsection{头文件 (LyraBaseAnimInstance.h)}

在头文件中，我们需要：
\begin{enumerate}
\item 声明代理结构体 FLyraBaseAnimInstanceProxy。
\item  在 ULyraBaseAnimInstance 中重载 CreateProxy 和 DestroyProxy。
\item  添加一些我们希望在工作线程中计算的属性，例如 GroundSpeed。
\item  定义 FLyraBaseAnimInstanceProxy 结构体，它继承自 FAnimInstanceProxy，并包含用于计算的成员变量和函数。
\end{enumerate}

\begin{amzcode}{c++}
// LyraBaseAnimInstance.h
// 1. 定义代理结构体，它将包含所有线程安全的数据和求值逻辑
USTRUCT()
struct FLyraBaseAnimInstanceProxy : public FAnimInstanceProxy
{
	GENERATED_BODY()

public:
	// 使用AnimInstance来初始化代理
	FLyraBaseAnimInstanceProxy(UAnimInstance* Instance);

	// 在工作线程上执行的更新函数，所有耗时计算都在这里
	virtual void Update(float DeltaSeconds) override;

	// 在游戏线程上，从AnimInstance拷贝数据到Proxy中
	virtual void PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds) override;

public:
	// 在工作线程上计算出的最终值
	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Proxy Data")
	float GroundSpeed = 0.0f;

	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Proxy Data")
	bool bIsFalling = false;

protected:
	// 从游戏线程拷贝过来的原始数据
	FVector CharacterVelocity;
	// ... 其他需要从游戏线程拷贝的数据
};


UCLASS(Abstract)
class LYRAALS_API ULyraBaseAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	ULyraBaseAnimInstance();

	// 在动画蓝图中可以直接使用的属性，由Proxy计算后更新
	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Movement")
	float GroundSpeed;

	UPROPERTY(Transient, BlueprintReadOnly, Category = "Lyra|Movement")
	bool bIsFalling;

protected:
	// 2. 重载CreateProxy和DestroyProxy来创建和销毁我们的代理实例
	virtual FAnimInstanceProxy* CreateProxy() override;
	virtual void DestroyProxy(FAnimInstanceProxy* InProxy) override;

	// NativeUpdateAnimation现在非常轻量，主要用于数据同步
	virtual void NativeUpdateAnimation(float DeltaSeconds) override;

	virtual void NativeInitializeAnimation() override;

protected:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Global Variables")
	TWeakObjectPtr<ALyraCharacter> LyraCharacter;
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lyra|Global Variables")
	TWeakObjectPtr<UCharacterMovementComponent> CharacterMovement;

private:
	// 动画实例的代理。这是UAnimInstance和其Proxy之间的桥梁。
	UPROPERTY(Transient)
	FLyraBaseAnimInstanceProxy Proxy;
};
\end{amzcode}

\subsubsection{源文件 (LyraBaseAnimInstance.cpp)}

在源文件中，我们实现各个函数的具体逻辑。
\begin{itemize}
\item \il{PreUpdate} (游戏线程): 从角色和移动组件获取数据，并将其存储在代理的成员变量中。
\item \il{Update} (工作线程): 使用代理中已存储的数据进行计算。\textbf{绝不}在此处访问任何\il{UObject}（如LyraCharacter）。
\item \il{NativeUpdateAnimation} (游戏线程): 将代理计算完成的结果拷贝回动画实例的属性，以便动画蓝图使用。
\end{itemize}

\begin{amzcode}{c++}
// LyraBaseAnimInstance.cpp
// --- Proxy Implementation ---

FLyraBaseAnimInstanceProxy::FLyraBaseAnimInstanceProxy(UAnimInstance* Instance)
	: FAnimInstanceProxy(Instance)
{
}

void FLyraBaseAnimInstanceProxy::PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds)
{
	// 在游戏线程执行：从动画实例和其拥有的对象（Actor等）安全地拷贝数据
	Super::PreUpdate(InAnimInstance, DeltaSeconds);

	ULyraBaseAnimInstance* LyraAnimInstance = Cast<ULyraBaseAnimInstance>(InAnimInstance);
	if (LyraAnimInstance && LyraAnimInstance->CharacterMovement.IsValid())
	{
		// 将需要的数据从游戏线程对象拷贝到代理的成员变量中
		CharacterVelocity = LyraAnimInstance->CharacterMovement->Velocity;
		bIsFalling = LyraAnimInstance->CharacterMovement->IsFalling();
		// ... 在这里拷贝所有其他需要的数据
	}
}

void FLyraBaseAnimInstanceProxy::Update(float DeltaSeconds)
{
	// 在工作线程执行：使用拷贝过来的数据进行所有耗时计算
	// 注意：这里绝对不能访问任何UObject指针（如LyraCharacter或CharacterMovement）
	Super::Update(DeltaSeconds);

	// 计算水平速度
	GroundSpeed = FVector(CharacterVelocity.X, CharacterVelocity.Y, 0.0f).Size();

	// ... 在这里执行所有其他的复杂计算
}


// --- AnimInstance Implementation ---

ULyraBaseAnimInstance::ULyraBaseAnimInstance()
{
	// 确保启用了多线程更新。如果动画蓝图的设置中未勾选，这行代码会强制开启。
	bUseMultiThreadedAnimationUpdate = true;
}

void ULyraBaseAnimInstance::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();
	if (AActor* OwningActor = GetOwningActor())
	{
		LyraCharacter = Cast<ALyraCharacter>(OwningActor);
		CharacterMovement = LyraCharacter.IsValid() ? LyraCharacter->GetCharacterMovement() : nullptr;
	}
}

FAnimInstanceProxy* ULyraBaseAnimInstance::CreateProxy()
{
	// 创建代理实例
	return new FLyraBaseAnimInstanceProxy(this);
}

void ULyraBaseAnimInstance::DestroyProxy(FAnimInstanceProxy* InProxy)
{
	// 销毁代理实例
	delete InProxy;
}

void ULyraBaseAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	// 在游戏线程执行：从代理获取计算结果，更新到动画实例的属性上
	// 这样动画蓝图就可以使用这些最新的值
	GroundSpeed = Proxy.GetGroundSpeed();
	bIsFalling = Proxy.GetIsFalling();
}
\end{amzcode}

这个模式的核心思想是 **数据分离**:

1.  **游戏线程 (Game Thread)**: PreUpdate 负责从游戏世界收集原始数据（如速度、状态）。
2.  **工作线程 (Worker Thread)**: Update 接收这些拷贝好的、线程安全的数据，并执行所有复杂的计算。
3.  **游戏线程 (Game Thread)**: NativeUpdateAnimation (或 PostUpdate) 将计算结果同步回 UAnimInstance，供动画蓝图使用。

这种方式结构清晰，性能和扩展性都非常出色，完全能够满足您未来大量计算的需求。
\subsection{github copilot示例及解决方案}
\paragraph{要点：}
动画蓝图不直接访问 Proxy。把要用到的值声明成 UAnimInstance 的 \il{UPROPERTY(BlueprintReadOnly)}，动画图会自动用到其在 Proxy 中的线程安全拷贝。

C++在 \il{NativeUpdateAnimation} 里计算并写入这些 UPROPERTY；Proxy 在 \il{PreUpdate} 把它们拷到线程安全字段给并行评估用。

如需在蓝图事件图读取“并行阶段的快照”，提供一个 BlueprintPure Getter，从游戏线程读取自定义 Proxy 的缓存。
在动画蓝图中使用方式：
在 ABP 的变量面板直接拖拽 Speed（或你的任意 UPROPERTY）进 AnimGraph，用于 BlendSpace、State Machine 条件等。
如果要读线程快照，调用 \il{GetSpeedTS_Snapshot} 蓝图函数节点。
下面示例添加一个 Speed 变量，并让 Proxy 在并行阶段使用其快照，同时提供一个蓝图 Getter 读取快照。

代理实现：
\begin{amzcode}{cpp}
#pragma once

#include "Animation/AnimInstanceProxy.h"

class ULyraBaseAnimInstance;

// 自定义 Proxy：仅存跨线程快照
struct FLyraBaseAnimInstanceProxy final : public FAnimInstanceProxy
{
	FLyraBaseAnimInstanceProxy() : FAnimInstanceProxy() {}
	explicit FLyraBaseAnimInstanceProxy(UAnimInstance* InInstance) : FAnimInstanceProxy(InInstance) {}

	// 线程安全快照(TS = Thread Safe)
	float SpeedTS = 0.f;

	virtual void PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds) override;
};
\end{amzcode}
\begin{amzcode}{cpp}
#include "AnimInst/LyraBaseAnimInstanceProxy.h"
#include "AnimInst/LyraBaseAnimInstance.h"

void FLyraBaseAnimInstanceProxy::PreUpdate(UAnimInstance* InAnimInstance, float DeltaSeconds)
{
	FAnimInstanceProxy::PreUpdate(InAnimInstance, DeltaSeconds);

	if (const auto* Inst = Cast<ULyraBaseAnimInstance>(InAnimInstance))
	{
		SpeedTS = Inst->GetSpeed(); // 从实例拷贝到线程安全字段
	}
}
\end{amzcode}
动画实例的实现：
\begin{amzcode}{cpp}
UCLASS(Transient, Blueprintable, Abstract)
class LYRAALS_API ULyraBaseAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:
	ULyraBaseAnimInstance() = default;

	virtual void NativeInitializeAnimation() override;
	virtual void NativeUpdateAnimation(float DeltaSeconds) override;

	// 供 Proxy 读取，也可在 C++/蓝图读取（动画图会自动使用它的代理镜像）
	UFUNCTION(BlueprintPure, Category="Lyra|Movement")
	float GetSpeed() const { return Speed; }

	// 可选：蓝图读取并行快照（仅在游戏线程调用）
	UFUNCTION(BlueprintPure, Category="Lyra|Movement")
	float GetSpeedTS_Snapshot() const;

protected:
	// 动画蓝图直接使用这个变量（出现在变量面板，可接到 BlendSpace/条件等）
	UPROPERTY(Transient, BlueprintReadOnly, Category="Lyra|Movement", meta=(AllowPrivateAccess="true"))
	float Speed = 0.f;

	// 工程已有的弱引用
	UPROPERTY(Transient, BlueprintReadOnly, Category="Lyra|Global Variables")
	TWeakObjectPtr<ALyraCharacter> LyraCharacter;

	UPROPERTY(Transient, BlueprintReadOnly, Category="Lyra|Global Variables")
	TWeakObjectPtr<UCharacterMovementComponent> CharacterMovement;

	// 接入自定义 Proxy
	virtual FAnimInstanceProxy* CreateAnimInstanceProxy() override;
	virtual void DestroyAnimInstanceProxy(FAnimInstanceProxy* InProxy) override;
};
\end{amzcode}
实现：
\begin{amzcode}{cpp}
void ULyraBaseAnimInstance::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();

	LyraCharacter = Cast<ALyraCharacter>(TryGetPawnOwner());
	if (LyraCharacter.IsValid())
	{
		CharacterMovement = LyraCharacter->GetCharacterMovement();
	}
}

void ULyraBaseAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	// 运行时可能重新获取
	if (!LyraCharacter.IsValid())
	{
		LyraCharacter = Cast<ALyraCharacter>(TryGetPawnOwner());
		if (LyraCharacter.IsValid())
		{
			CharacterMovement = LyraCharacter->GetCharacterMovement();
		}
	}

	// 计算给动画图使用的值（游戏线程）
	Speed = CharacterMovement.IsValid() ? CharacterMovement->Velocity.Size() : 0.f;
}

FAnimInstanceProxy* ULyraBaseAnimInstance::CreateAnimInstanceProxy()
{
	return new FLyraBaseAnimInstanceProxy(this);
}

void ULyraBaseAnimInstance::DestroyAnimInstanceProxy(FAnimInstanceProxy* InProxy)
{
	delete static_cast<FLyraBaseAnimInstanceProxy*>(InProxy);
}

float ULyraBaseAnimInstance::GetSpeedTS_Snapshot() const
{
	const auto& P = GetProxyOnGameThread<FLyraBaseAnimInstanceProxy>();
	return P.SpeedTS;
}
\end{amzcode}
\subsection{结论}

考虑到您“预计未来会有大量的求值计算”，强烈建议从一开始就使用 \il{FAnimInstanceProxy} 模式。

虽然初始设置稍微复杂，但它提供的清晰结构、高性能和强大的扩展性，将为项目未来的维护和性能优化带来巨大好处，完全符合您的长远需求。只重载 \il{NativeThreadSafeUpdateAnimation} 是一种捷径，但对于复杂系统而言，它很快会成为技术债务。

\section{Animation Layer Interfaces 概述}

Animation Layer Interfaces（简称 ALI）是组织和复用动画层一种结构。在动画蓝图的事件图中，一团代码可以折叠成函数，从而达到复用/变量化的目的。然而，对于动画结点却不可以，\il{ALI}主要是为了解决这个问题而设计的。当然，如果不使用这种方式，也可以达到同样的目的：例如，在\il{UAnimInstance}派生类中设计一些动画序列变量，然后在运行时，根据某个状态来更改，但系统提供了更健壮、更灵活的开箱即用的产品，没理由不使用。

\begin{itemize}
  \item 目标：创建一个 Animation Layer Interface，在其中定义一个或多个 Animation Layers（例如 Idle Layer），并在动画蓝图中使用这些层以实现模块化动画逻辑。
  \item 创建流程（简要）：
    \begin{enumerate}
      \item 在 Content 目录中右键 → Animation → Animation Layer Interface，创建一个接口（示例命名为 \il{ALI_Lyra}）。
      \item 在接口内添加动画层（例如添加 Idle Layer）；该层通常不需要输入参数，仅有输出。
      \item 在目标 Animation Blueprint（如 \il{ABP_Base}）中打开 Class Settings，添加并实现该接口（添加 \il{ALI_Lyra}）。
      \item 将生成的 Idle Layer 拖入 Anim Graph 并连接；具体层的实现可以粘贴或复用现有的 Blend Poses（例如枪械的 Blend Poses）来快速测试。
    \end{enumerate}
  \item 推荐架构：
    \begin{itemize}
      \item 虽然可以直接在 ABP\_Base 中实现这些层并运行，但更优的做法是把具体层的实现放到另一个专门的 Animation Blueprint（例如 ABP\_Layers）中。
      \item ABP\_Base 负责主 Anim Graph，并通过实现的接口调用 ABP\_Layers 中的各个 layer，从而实现更好的模块化、可维护性和复用性。
    \end{itemize}
  \item 作用与背景：该方法被 ALS v4 以及 Lyra 的高级 locomotion 等项目采用，便于把动画层拆分为可重用的模块。
  \item 备注：视频演示中演示了将 Blend Poses 直接粘贴到层中以测试功能，但讲师建议采用分离层实现的方式，后续视频会进一步解释和展示该方法的优点。
\end{itemize}



\section{Link Anim Class 详述}

本视频讲解如何使用独立的 Animation Blueprint（下称 ABP\_Layers）来承载动画层，并在角色蓝图中通过 "Link Anim Class Layers" 节点将这些层替换到主动画蓝图（ABP\_Base）中，实现模块化与复用。详细内容分点说明如下：

\subsection{设计目标与总体思路}
\begin{itemize}
  \item 将与\emph{动画层}（Animation Layers）相关的内容从主动画蓝图（ABP\_Base）拆分出来，放入专门的动画蓝图（ABP\_Layers），以提升清晰度、优化与易扩展性。
  \item 在 ABP\_Base 中保留与动画计算相关的逻辑（例如速度、其他数值计算）与主 Anim Graph，而把具体的 layer 实现交给 ABP\_Layers。
  \item 在角色类（Character Class）的生命周期中（例如 EventBeginPlay），调用 LinkAnimClassLayers 将 ABP\_Base 中的占位层替换为 ABP\_Layers 中实现的层，从而在运行时“接入”具体层的动画输出。
\end{itemize}

\subsection{创建 ABP\_Layers（步骤）}
\begin{enumerate}
  \item 在 Content Drawer 中进入 ALS/Animation Blueprints，右键 → Animation Blueprint，创建一个新的动画蓝图，命名为 \texttt{ABP\_Layers}。
  \item 打开 \texttt{ABP\_Layers}，进入 Class Settings，点击 Implement Interfaces，然后添加之前创建的 Animation Layer Interface（如 ALI\_Lyra）。这样 \texttt{ABP\_Layers} 就包含了接口中定义的各个 layer。
  \item 注意：因为 \texttt{ABP\_Layers} 仅作为 layer 的容器，它的 Anim Graph 不需要输出最终姿势（不作为主输出），因此可以不维护 Event Graph 或其它不必要的部分。
\end{enumerate}

\subsection{在 ABP\_Layers 中实现 Idle Layer（示例实现）}
\begin{enumerate}
  \item 在 Idle Layer 的 Anim Graph 内，添加一个 Sequence Player 结点用于播放静止动画序列。
  \item 将 Sequence Player 的动画资源暴露为一个变量（将 Sequence Player 的动画 pin 提升为变量），命名为 \texttt{IdleAnim}，以便从外部（或编辑器）为该层设置不同的动画资产。
  \item 在示例中，将 \texttt{IdleAnim} 指向一个无武装（unarmed）的 idle 动画，编译以保存设置。注意：仅设置变量并不会立即在角色上显示效果，需完成链接流程。
\end{enumerate}

\subsection{在角色类中链接层（Link Anim Class Layers）}
\begin{itemize}
  \item 在角色类（Character Class）的 EventBeginPlay 中，获取角色的 Mesh（骨骼网格体），并调用节点 Link Anim Class Layers（或等价 API），将所创建的 \texttt{ABP\_Layers} 指定为要链接的动画蓝图层集合。
  \item 该节点的作用：在运行时将 ABP\_Base 中存在但未实现具体内容的所有动画层（占位层）替换为 \texttt{ABP\_Layers} 中实现的对应层，从而让角色使用这些具体层的动画（例如已设置的 unarmed idle）。
  \item 演示效果：链接后运行游戏，角色显示为无武装的 idle 状态；如果断开链接或不链接，则会回到原有占位姿势或无效果。
\end{itemize}

\subsection{关键要点与好处}
\begin{itemize}
  \item 模块化：将层拆分到单独蓝图后，可以独立开发、测试与复用（例如为武器、配件或特殊动作快速添加 layer）。
  \item 可配置性：通过在 ABP\_Layers 中使用公开变量（如 \texttt{IdleAnim}），可以在实例化或通过链接时灵活替换动画资产。
  \item 可扩展性：当需要添加新武器（如火箭发射器）或新动作时，只需在 ABP\_Layers 中新增 layer 并在角色中链接，无需修改 ABP\_Base 的核心计算逻辑。
  \item 性能与清晰性：把计算（速度、状态等）保留在 ABP\_Base，而把具体输出交给 ABP\_Layers，有助于代码/蓝图组织更清晰，且便于优化和多人协作。
\end{itemize}

\subsection{示例流程小结（按时序）}
\begin{enumerate}
  \item 在 Content 中创建 \texttt{ABP\_Layers}，并在 Class Settings 中实现 Animation Layer Interface（如 ALI\_Lyra）。
  \item 在 \texttt{ABP\_Layers} 中为每个 layer（示例：Idle Layer）实现动画逻辑，并将关键动画资源暴露为变量（例如 \texttt{IdleAnim}）。
  \item 在角色类的 EventBeginPlay 中调用 LinkAnimClassLayers，将 \texttt{ABP\_Layers} 链接到当前角色的 Anim Class Layers。
  \item 运行时，ABP\_Base 中的占位层将被替换为 \texttt{ABP\_Layers} 的实现，从而展现预期动画。
\end{enumerate}
\subsection{动画层级关系图}
% 使用 \resizebox{\linewidth}{!}{...} 以确保图形横向填满页面宽度
\resizebox{\linewidth}{!}{%
\begin{tikzpicture}[
  scale=0.95, % 内部微调比例（resizebox 已负责整体缩放）
  every node/.style={font=\small},
  node distance=10mm and 20mm,
  iface/.style={draw=blue!70, fill=blue!8, thick, rounded corners, align=center, minimum width=36mm},
  base/.style={draw=orange!75, fill=orange!8, thick, rounded corners, align=center, minimum width=36mm},
  layers/.style={draw=teal!70, fill=teal!8, thick, rounded corners, align=center, minimum width=36mm},
  layerexp/.style={draw=green!70, fill=green!12, thick, rounded corners, align=center, minimum width=30mm},
  collapsed/.style={draw=gray!40, fill=gray!6, rounded corners, align=center, minimum width=18mm, minimum height=6mm, font=\scriptsize},
  char/.style={draw=black!70, fill=black!6, thick, rounded corners, align=center, minimum width=36mm},
  linknode/.style={draw=red!70, fill=red!6, thick, rounded corners, align=center, minimum width=30mm},
  legendbox/.style={draw=black!40, fill=white, rounded corners, font=\footnotesize, inner sep=6pt},
  arrow/.style={-{Stealth[scale=1]}, thick},
  dashedarrow/.style={-{Stealth[scale=1]}, thick, dashed}
]

  % Top-level nodes
  \node[iface] (content) {Content / Interfaces};
  \node[below=of content, iface] (ali) {ALI\_Lyra\\(Animation Layer Interface)};

  % Middle: ABP_Base (left) and ABP_Layers (right)
  \node[below left=15mm and 20mm of ali, base] (abpbase) {ABP\_Base\\(主动画蓝图)\\占位 Layer};
  \node[below right=15mm and 20mm of ali, layers] (abplayers) {ABP\_Layers\\(Layer 容器)\\实现各层};

  % Layer implementations under ABP_Layers
  \node[below=of abplayers, layerexp] (idle) {Idle Layer\\Sequence Player\\\texttt{IdleAnim} (variable)};
  \node[right=12mm of idle, collapsed] (weapon) {...\\Weapon Layers};
  \node[left=12mm of idle, collapsed] (upperbody) {...\\UpperBody Layers};

  % Placeholder under ABP_Base
  \node[below=of abpbase, collapsed] (placeholder) {Idle Layer (占位)};

  % Character and link node (left side)
  \node[left=34mm of abpbase, char] (character) {Character Class\\EventBeginPlay};
  \node[below=of character, linknode] (link) {LinkAnimClassLayers};

  % Connections
  \draw[arrow] (content) -- (ali);
  \draw[arrow] (ali) -- (abpbase) node[midway, left, font=\small] {接口实现};
  \draw[arrow] (ali) -- (abplayers) node[midway, right, font=\small] {接口实现};

  \draw[arrow] (abplayers) -- (idle) node[midway, right, font=\small] {包含具体实现};
  \draw[arrow] (abplayers) -- (upperbody);
  \draw[arrow] (abplayers) -- (weapon);

  \draw[arrow] (abpbase) -- (placeholder) node[midway, left, font=\small] {占位层};

  \draw[arrow] (character) -- (link);
  \draw[dashedarrow] (link) to[bend left=20] node[midway, above, font=\small] {指定 \texttt{ABP\_Layers}} (abplayers);
  \draw[dashedarrow] (link) to[bend right=20] node[midway, above, font=\small] {替换 ABP\_Base 的层} (abpbase);

  % Legend placed above the note (under the figure)
  \node[legendbox, below=12mm of upperbody, anchor=north] (legend) {
    \begin{tabular}{@{}l@{\quad}l}
      \tikz \node[iface, minimum width=6mm, minimum height=4mm] {}; & Interface / Content \\
      \tikz \node[base, minimum width=6mm, minimum height=4mm] {}; & ABP\_Base (占位) \\
      \tikz \node[layers, minimum width=6mm, minimum height=4mm] {}; & ABP\_Layers (实现容器) \\
      \tikz \node[layerexp, minimum width=6mm, minimum height=4mm] {}; & 展开层（具体实现） \\
      \tikz \node[collapsed, minimum width=6mm, minimum height=4mm] {}; & 折叠/占位 层 \\
      \tikz \node[linknode, minimum width=6mm, minimum height=4mm] {}; & 运行时链接节点
    \end{tabular}
  };

  % EXAMPLE / NOTE moved to bottom (below legend)
  \node[draw=none, below=6mm of legend, align=left, font=\footnotesize] (note) {
    示例与说明：运行时调用 \texttt{LinkAnimClassLayers} 会将 \texttt{ABP\_Base} 中的占位层替换为 \texttt{ABP\_Layers} 中实现的对应层（例如 Idle Layer），从而使角色显示设定好的动画（如 unarmed idle）。图中绿色节点为具体实现，灰色为占位/折叠表示。
  };

\end{tikzpicture}%
} % end resizebox

\subsection{结语与后续内容}
本视频主要演示了如何把动画层作为独立容器并在运行时链接回主动画蓝图，从而获得模块化和复用的优势。作者在下一视频中将继续展示这些 ABP\_Layers 的更高级用法与亮点，建议继续观看以理解完整工作流与实战技巧。

\setchapterimage{./images/root.png}
\chapter{Root Motion}
\section{Root Motion 启用与否的差异}

\subsection{概念性差异}
\begin{itemize}
    \item \textbf{启用 Root Motion：} 动画资产携带根骨骼的位移和旋转。在动画评估时，引擎会提取这部分运动（即“根运动”），并用它来驱动 \texttt{Actor} 或角色的世界变换（如果 \texttt{AnimInstance} 的根运动模式允许）。动画本身会直接导致角色在游戏世界中移动。
    \item \textbf{未启用 Root Motion：} 动画通常是“在原地播放”（in-place），根骨骼不包含全局位移。角色的位置由 \texttt{CharacterMovementComponent} 或自定义代码逻辑驱动，动画只负责骨骼的相对姿态。
\end{itemize}

\subsection{主要注意事项}
\begin{itemize}
    \item \textbf{提取时机与设置：} 即使动画包含根运动数据，是否实际应用它取决于 \texttt{AnimInstance} 的 \texttt{Root Motion Mode} 设置（例如 \texttt{Root Motion from Everything} 或 \texttt{Root Motion from Montages Only}）。通常，将根运动放在 \texttt{AnimMontage} 中更容易控制其生效时机。

    \item \textbf{与 CharacterMovement 的协作：} 启用根运动时，通常由\textbf{动画驱动位移}，而 \il{CharacterMovementComponent} 则负责处理由该位移引发的碰撞、滑动和地面检测。混合使用原地动画和根运动动画时，必须明确哪个系统在何时负责位移。

    \item \textbf{网络复制：} 根运动的网络复制很复杂。默认情况下，网络移动基于 \texttt{CharacterMovementComponent} 的客户端预测和服务器修正。启用根运动时，需要依赖引擎内置的根运动复制机制或实现专门的服务器权威逻辑，否则极易出现客户端与服务器不同步的问题。

    \item \textbf{播放控制与蒙太奇：} 强烈建议将带有根运动的关键动作（如翻滚、特殊攻击）放在 \texttt{AnimMontage} 中。这便于精确控制根运动的开始、结束、同步，并且引擎对蒙太奇的根运动支持更为明确和健壮。

    \item \textbf{骨骼与资源制作：} 确保根骨骼是正确的，并且位移信息已烘焙到根骨骼上。注意，动画重定向（Retargeting）过程可能会改变或丢失根运动数据。不要将位移信息放在加法（additive）动画层中。

    \item \textbf{混合和层级：} 混合多个带有根运动的动画会导致位移合成变得复杂且不可预测。通常应避免在多个动画层上同时启用完整的根运动。

    \item \textbf{Root Motion Root Lock / 原点策略：} 根据需要选择合适的根锁定选项（如 \texttt{Reference Pose}, \texttt{Anim First Frame}, \texttt{Zero}），这会影响姿态和旋转的参考点，从而影响角色最终的位置和朝向。

    \item \textbf{调试与测试：} 在编辑器中开启根运动可视化功能，检查实际提取的运动轨迹是否符合预期。在不同的网络条件、物理和碰撞设置下进行充分测试。

    \item \textbf{线程安全与评估：} 动画评估（包括根运动提取）可能在工作线程（动画代理线程）上执行。最终的位移应用会回到游戏线程。遵循代理模式：在游戏线程的 \texttt{PreUpdate} 中快照所需数据，在工作线程中计算，在游戏线程的 \texttt{PostUpdate} 中应用结果。
\end{itemize}

\subsection{何时使用}
\begin{itemize}
    \item \textbf{使用 Root Motion：} 适用于需要动画与位移精确同步的复杂动作，例如翻滚、跳跃、攀爬、特定的攻击位移等。
    \item \textbf{不使用 Root Motion：} 适用于常规的、由玩家输入控制的持续性移动，如行走、奔跑。将位移控制权交给 \texttt{CharacterMovementComponent} 更便于网络预测和物理交互。
\end{itemize}

\subsection{简短结论}
启用根运动会将位移的控制权“从动画赋予世界”，其管理较为复杂，但适用于动作驱动的移动。禁用根运动则将位移控制权交给代码（如 \texttt{CharacterMovementComponent}），更易于网络同步和物理预测。
\subsubsection{从动画赋予世界的解释}
这句话的意思是，当启用根运动时，角色在游戏世界中的实际位置移动，是由播放的动画文件本身来决定的，而不是由常规的角色移动代码（如 CharacterMovementComponent）来控制。
可以这样理解：
\begin{itemize}
\item 常规情况 (未启用根运动):
	\begin{enumerate}
		\item 控制权在代码/蓝图：你按下 W 键，CharacterMovementComponent 计算出角色应该向前移动，并更新其在世界中的位置。
		\item 动画只是“表演”：动画系统播放一个“原地行走”的动画来匹配这个移动。动画本身并没有让角色真的前进，它只是在原地摆动腿。位移是由代码驱动的。
	\end{enumerate}
\item 启用根运动后:
	\begin{enumerate}
	\item 控制权在动画文件：动画师在制作一个“前冲攻击”的动画时，已经让角色的根骨骼在动画中向前移动了1米。
	\item 动画“驱动”世界：当游戏播放这个动画时，引擎会提取出根骨骼移动1米的数据，并将其应用到角色在游戏世界中的实际位置上。角色真的向前移动了1米，因为动画文件就是这么设计的。
	\end{enumerate}
\end{itemize}	
所以，“从动画赋予世界”就是指，将动画文件（UAnimSequence）中包含的位移信息（“从动画”），直接应用为角色在游戏世界（“世界”）中的实际位置变化（“赋予”）。控制权从通用的移动代码转移到了特定的动画资产上。
\section{Force Root Lock 的作用}

\texttt{Force Root Lock} 是一个可以在动画序列(\texttt{AnimSequence})或动画蒙太奇(\texttt{AnimMontage})中设置的选项。其核心作用是：

\textbf{强制禁用根运动中的“平移”部分，但通常会保留“旋转”部分。}

\subsection{具体效果}
当勾选此选项时：
\begin{itemize}
    \item \textbf{阻止位移：} 即使动画文件本身包含让角色向前、向后或侧向移动的根运动数据，角色的碰撞体（Capsule）也不会在世界中发生实际的位置移动。角色在平移上被“锁定”在原地。
    \item \textbf{保留姿态和旋转：} 动画的姿态（骨骼如何弯曲）和根骨骼的旋转（角色朝向的变化）仍然会被应用。
\end{itemize}

\subsection{主要使用场景}
这个选项非常有用，主要用于以下情况：
\begin{itemize}
    \item \textbf{上半身动画蒙太奇：} 这是最常见的用法。想象一个角色正在奔跑（由 \texttt{CharacterMovementComponent} 控制移动），此时需要播放一个上半身的攻击或施法动画。这个攻击动画本身可能带有向前冲刺的根运动。
    \begin{itemize}
        \item \textbf{不使用 \texttt{Force Root Lock}：} 角色在奔跑的基础上，还会叠加攻击动画的根运动，导致一个不自然的、过快的“二次加速”前冲。
        \item \textbf{使用 \texttt{Force Root Lock}：} 角色的奔跑速度完全由 \texttt{CharacterMovementComponent} 控制。攻击蒙太奇播放时，只会应用其攻击的姿态和身体的扭转，而不会应用其向前冲刺的位移。这样看起来就像角色在保持奔跑速度的同时，完成了攻击动作。
    \end{itemize}

    \item \textbf{需要动画姿态但不需要位移的场合：} 你可能喜欢某个带根运动的动画（比如一个有力的挥拳动作），但希望角色在原地完成这个动作，而不是像动画数据显示的那样向前冲一步。勾选 \texttt{Force Root Lock} 就可以让你“借用”这个动画的姿态，而忽略它的位移。

    \item \textbf{平滑过渡：} 在从一个根运动动画过渡回一个“原地”（In-place）动画时，使用这个选项可以帮助防止角色位置在过渡瞬间发生跳变。
\end{itemize}

\subsection{与之前概念的联系}
回到“从动画赋予世界”这句话：
\begin{itemize}
    \item \textbf{常规根运动：} 是“动画”将它的“位移和旋转”赋予“世界”中的角色。
    \item \textbf{启用 \texttt{Force Root Lock}：} 你对引擎说：“这次动画只能把它的‘旋转和姿态’赋予世界，把‘位移’留下，位移由我（代码/\texttt{CharacterMovementComponent}）自己控制。”
\end{itemize}

因此，\texttt{Force Root Lock} 是一个强大的工具，它让你能更精细地控制根运动，决定是完全采用动画的运动数据，还是只采用其中的一部分。

\end{document}
