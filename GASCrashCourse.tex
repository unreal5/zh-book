\documentclass[10pt,CJKmath]{zhbook-v1}
%\xeCJKsetup{CJKmath=true}
\usepackage{fontawesome5}
\setmintedinline[c++]{breaklines,breakanywhere,bgcolor=none,breakanywheresymbolpre=\rotatebox{-90}{\mbox{\tiny\faLevelDown*}}}
\newcommand{\il}[1]{\mintinline{c++}{#1}}%

\newtcbox{\mybox}[1][red]{on line,colupper=black,fonttitle=\bfseries,
 arc=4pt,outer arc=4pt,colback=red!10!white,colframe=#1!50!black,
 boxsep=0pt,left=2pt,right=2pt,top=2pt,bottom=2pt,
 boxrule=1pt,leftrule=1pt,rightrule=1pt}
 
\begin{document}
		%\frontmatter
    %\tableofcontents

\mainmatter
\setchapterimage{./images/background}

\chapter{ASC组件}
\section{GAS核心}

本文详细阐述了游戏技能系统（Gameplay Ability System, GAS）的各个核心组件。GAS是一个功能强大且高度可扩展的框架，用于管理游戏中的角色技能、属性和各种交互效果。理解其核心构成是高效运用GAS的关键。

\subsection{简述}
游戏技能系统 (GAS) 是一个内置于虚幻引擎 (Unreal Engine) 的框架，旨在帮助开发者管理复杂的角色技能、属性（如生命值、法力值）以及状态效果（如中毒、眩晕）。它通过一系列协同工作的核心组件，提供了一个为网络多人游戏设计的、结构清晰且易于扩展的解决方案。

\subsection{核心组件}

GAS主要由以下几个部分构成：

\subsubsection{技能系统组件 (Ability System Component, ASC)}
\textbf{技能系统组件}是GAS的心脏。它是一个可以直接添加到Actor上的组件（Actor Component），负责处理GAS中几乎所有的交互。\dfntxt{任何希望使用技能、拥有属性或接收游戏效果的Actor都必须拥有一个ASC}。它扮演着数据中心和通信枢纽的角色。

\subsubsection{属性集 (Attribute Set)}
在GAS中，角色的数值（如生命、攻击力、速度等）被称为\textbf{属性 (Attributes)}。
\begin{itemize}
    \item \textbf{定义:} \textbf{属性集}是一个包含了一组相关属性的类。它定义了一个Actor可以拥有的所有属性。
    \item \textbf{注册:} 当一个Actor拥有一个属性集时，该属性集会\dfntxt{自动在该Actor的ASC上进行注册}\footnote{通过\il{PostInitializeComponents}虚函数实现，具体代码参考}，使得这些属性能够被系统识别和修改。
    \item \textbf{延伸:} 属性的修改通常不是直接进行的，而是通过\textbf{游戏效果 (Gameplay Effect)}来完成。属性集内部可以定义“元属性”（Meta Attributes），例如“伤害（Damage）”，它本身不被存储，但在游戏效果应用时作为一个临时变量，用于计算对其他属性（如“生命值”）的最终影响。
\end{itemize}

\subsubsection{Gameplay Ability}
\textbf{游戏技能}是Actor可以执行的动作或技能，例如跳跃、攻击、施法等。
\begin{itemize}
    \item \textbf{封装:} 它们将游戏玩法的逻辑封装在独立的类中，使得逻辑清晰且易于复用。
    \item \textbf{激活:} 技能被赋予给ASC，并通过ASC来激活。一个ASC可以同时激活多个技能。
    \item \textbf{控制:} 技能可以被其他技能阻塞、取消，甚至可以触发其他技能。
    \item \textbf{成本与冷却:} 技能可以设定\textbf{成本 (Cost)}和\textbf{冷却 (Cooldown)}。成本会消耗某个属性（如法力值），而冷却则会阻止技能在一段时间内被再次激活。
    \item \textbf{异步性:} 技能拥有自己的事件图表，支持执行持续一段时间（多帧）的\textbf{潜在动作 (Latent Actions)}，例如持续施法。
\end{itemize}

\subsubsection{游戏效果 (Gameplay Effect, GE)}
\textbf{游戏效果}是用于修改Actor属性的“数据配方”。
\begin{itemize}
    \item \textbf{功能:} 它们被用来施加伤害、治疗、增益 (Buffs) 或减益 (Debuffs) 效果。
    \item \textbf{持续类型:} 游戏效果可以是即时的 (\il{Instant})、持续一段时间的 (\il{Duration})，或是无限的 (\il{Infinite})，直到被手动移除。
    \item \textbf{延伸功能:} 除了修改属性，GE还可以赋予其他技能、添加\textbf{游戏标签 (Gameplay Tags)}或触发\textbf{游戏提示 (Gameplay Cues)}。
\end{itemize}

\subsubsection{游戏提示 (Gameplay Cue, GC)}
\textbf{游戏提示}专门用于处理非游戏逻辑相关的表现效果，如播放粒子特效、音效、镜头晃动等。
\begin{itemize}
    \item \textbf{解耦:} 它们将表现层与逻辑层完全解耦。例如，一个“火球术”的\texttt{Gameplay Ability}在击中目标时，只需触发一个“Cue.Fire.Explosion”的GC事件，而具体的爆炸特效和声音则由监听这个事件的GC对象来处理。
    \item \textbf{网络同步:} GC的设计天然支持网络同步，极大地简化了在多人游戏中实现表现效果的复杂度。
\end{itemize}

\subsubsection{技能任务 (Ability Tasks)}
\textbf{技能任务}是\texttt{Gameplay Ability}中可以使用的异步工作节点。它们简化了在技能中执行复杂或耗时操作的流程。
\begin{itemize}
    \item \textbf{常见任务:} 引擎内置了许多常用的任务，例如“播放蒙太奇动画 (Play Montage)”、“等待事件 (Wait for Gameplay Event)”、“等待属性变化 (Wait for Attribute Change)”以及“延迟 (Delay)”。
    \item \textbf{简化逻辑:} 它们使得在技能蓝图中以直观、线性的方式实现复杂的异步逻辑成为可能。
\end{itemize}

\subsubsection{游戏标签 (Gameplay Tag)}
\textbf{游戏标签}是一种分层级的命名标记（例如 \texttt{State.Buff.Stunned}），虽然它不是GAS独有的系统，但在GAS中扮演着至关重要的角色。
\begin{itemize}
    \item \textbf{识别与状态:} 标签可以用来识别技能、标记Actor的状态（如“昏迷”、“隐身”）。
    \item \textbf{逻辑控制:} 技能之间通过标签来进行交互，例如，一个拥有“昏迷”标签的Actor可能被禁止使用某些技能。技能的冷却和成本也可以通过标签来管理。
    \item \textbf{事件通信:} 标签是触发游戏事件的核心机制，技能可以等待特定的标签事件来执行后续逻辑。
\end{itemize}

\subsection{总结与延伸}
GAS的这些核心组件共同构建了一个强大而灵活的系统。它们之间的关系可以概括为：
\begin{quote}
		\itshape
    一个Actor上的\textbf{技能系统组件 (ASC)}管理着其拥有的\textbf{属性集 (Attribute Set)}和\textbf{游戏技能 (Gameplay Ability)}。当一个\textbf{技能}被激活时，它可能会消耗某个\textbf{属性}作为成本，并应用一个\textbf{游戏效果 (Gameplay Effect)}到目标身上。这个\textbf{游戏效果}会修改目标ASC上的\textbf{属性}，并可能触发一个\textbf{游戏提示 (Gameplay Cue)}来播放视觉特效。整个过程的状态和逻辑流转则由\textbf{游戏标签 (Gameplay Tag)}来精确控制。
\end{quote}
这种架构不仅使得游戏逻辑模块化，而且其为网络同步设计的底层机制，让开发者能够更专注于玩法设计，而不是底层的技术实现。


\section{ASC}
本节详细介绍了在虚幻引擎中设置和使用游戏技能系统组件 (Ability System Component, ASC) 的核心概念和两种主要实现模式。

\subsection{核心概念}
\begin{itemize}
    \item \textbf{ASC的本质}: 它是一个\texttt{ActorComponent}，必须由一个\texttt{Actor}拥有。
    \item \textbf{两个关键指针}: ASC内部维护两个重要的变量，一旦初始化，ASC会跟踪这两个重要变量：
    \begin{description}
        \item[\texttt{OwnerActor}:] ASC的逻辑所有者，负责管理ASC的生命周期和状态。
        \item[\texttt{AvatarActor}:] ASC在游戏世界中的视觉表现，通常是玩家或NPC的角色模型。技能（Abilities）的动画和效果通常在这个\texttt{Actor}上播放。
    \end{description}
\end{itemize}

\subsection{两种主流的ASC所有权模式}
\begin{enumerate}
    \item \textbf{模式一：由Pawn/Character直接拥有ASC}
    \begin{itemize}
        \item 在这种模式下，\texttt{OwnerActor}和\texttt{AvatarActor}都指向同一个\texttt{Pawn}或\texttt{Character}。
        \item \textbf{优点}: 实现简单直接。
        \item \textbf{适用场景}: 通常用于AI控制的NPC或敌人，因为它们通常不需要像玩家那样持久化的状态。
    \end{itemize}
    
    \item \textbf{模式二：由PlayerState拥有ASC}
    \begin{itemize}
        \item 在这种模式下，\texttt{OwnerActor}指向\texttt{PlayerState}，而\texttt{AvatarActor}指向玩家控制的\texttt{Pawn}或\texttt{Character}。
        \item \textbf{优点}:
        \begin{itemize}
            \item \textbf{状态持久化}: 由于\texttt{PlayerState}在玩家的整个连接会话中是持久的，即使其控制的\texttt{Character}死亡并重生，ASC及其所包含的技能和属性状态也能得以保留。
            \item \textbf{代码解耦}: 保持\texttt{Character}类的整洁，将技能相关的逻辑分离到\texttt{PlayerState}中。
        \end{itemize}
        \item \textbf{适用场景}: 强烈推荐用于玩家控制的角色。
    \end{itemize}
\end{enumerate}

\subsection{\texttt{IAbilitySystemInterface} 接口}
\begin{itemize}
    \item 这是一个提供单一函数 \texttt{GetAbilitySystemComponent()} 的接口。
    \item GAS框架的许多内部系统都依赖此接口来从一个\texttt{Actor}获取其ASC。
    \item \textbf{实现建议}: 应该在能够提供ASC的\texttt{Actor}上实现此接口。
    \begin{itemize}
        \item 如果ASC在\texttt{Character}上，则\texttt{Character}实现接口并直接返回其ASC。
        \item 如果ASC在\texttt{PlayerState}上，\texttt{Character}仍然需要实现该接口，但其实现逻辑是从其\texttt{PlayerState}中获取并返回ASC。
    \end{itemize}
\end{itemize}

\subsection{ASC的初始化流程}
\begin{enumerate}
    \item \textbf{创建并配置ASC}: 在其所有者（如此处为\texttt{PlayerState}）的构造函数中，使用\texttt{CreateDefaultSubobject}创建ASC实例。
    \item \textbf{设置网络复制}:
    \begin{itemize}
        \item 调用\texttt{SetIsReplicated(true)}使其可复制。
        \item 调用\texttt{SetReplicationMode()}设置为\texttt{Mixed}或\texttt{Full}。对于玩家角色，\texttt{Mixed}模式是最佳选择，它为所有者提供完整信息，为其他客户端提供最简信息，从而优化网络带宽。
        \item 建议提高\texttt{PlayerState}的\texttt{NetUpdateFrequency}（例如设置为100），以确保技能状态的快速同步。
    \end{itemize}
    \item \textbf{初始化Owner和Avatar}: 必须调用ASC的\texttt{InitAbilityActorInfo()}函数，并传入正确的\texttt{OwnerActor}和\texttt{AvatarActor}。
    \begin{itemize}
        \item \textbf{服务器端}: 在\texttt{Character}的\texttt{PossessedBy()}函数中调用，因为此时\texttt{Controller}和\texttt{PlayerState}已经可用。
        \item \textbf{客户端}: 在\texttt{Character}的\texttt{OnRep\_PlayerState()}函数中调用，以确保在客户端\texttt{PlayerState}已经成功复制后才执行初始化。
    \end{itemize}
\end{enumerate}


\section{Gameplay Ability (GA) 基础}
本节主要介绍了游戏技能（Gameplay Ability）的基本概念、如何在虚幻引擎编辑器中创建它，以及其核心属性的配置。

\subsection{创建与组织}
\begin{itemize}
    \item \textbf{创建方式}: 可以通过C++创建基类，也可以直接在编辑器中创建蓝图类。本节首先演示了如何创建游戏技能蓝图（Gameplay Ability Blueprint）。
    \item \textbf{命名约定}: 建议使用\texttt{GA\_}作为游戏技能蓝图的前缀，例如\texttt{GA\_Primary}。
    \item \textbf{文件组织}: 建议在项目中创建一个专门的\texttt{AbilitySystem}文件夹，并在其中根据技能的使用者（如\texttt{Player}、\texttt{Enemy}）进一步组织。
\end{itemize}

\subsection{Gameplay Ability 蓝图核心事件}
\begin{itemize}
    \item \mybox[blue]{\texttt{Event ActivateAbility}}: 这是技能被激活时触发的事件，类似于\texttt{Actor}的\texttt{BeginPlay}。所有技能的主要逻辑都从这里开始。
    \item \mybox[blue]{\texttt{Event OnEndAbility}}: 当技能结束时触发的事件，用于执行清理工作或后续逻辑。
    \item \mybox[blue]{\texttt{EndAbility}节点}: 在技能逻辑执行完毕后，必须调用此节点来显式地结束技能，否则技能将一直处于激活状态。
\end{itemize}

\subsection{核心属性详解 (Details Panel - Advanced)}
\begin{description}
    \item \dfntxt{Instancing Policy}: 定义了技能对象的实例化方式，对性能和状态管理至关重要。
    \begin{itemize}
        \item \textbf{\texttt{Instanced per Execution} (默认)}: 每次激活技能都会创建一个新的技能实例。这允许多个相同技能的实例同时存在，但会增加内存开销。
        \item \textbf{\texttt{Instanced per Actor}}: 每个\texttt{Actor}只拥有一个该技能的实例。当技能被再次激活时，会重用这个实例。这是推荐的设置，因为它更节省资源。
        \item \textbf{\texttt{Non-Instanced}}: 技能不会被实例化为对象，不能保存状态（变量）。其行为类似于一个静态函数库，适用于无状态的、一次性的效果。
    \end{itemize}
    
    \item\dfntxt{Net Execution Policy}: 决定了技能在网络环境下的执行方式。
    \begin{itemize}
        \item \textbf{\texttt{Local Predicted} (默认)}: 客户端发起激活后，技能会立即在本地执行（预测），同时向服务器发送请求。服务器验证后也会执行该技能。这是处理玩家输入的理想选择，能提供流畅的响应体验。
        \item \textbf{\texttt{Local Only}}: 技能只在本地执行，不会通知服务器。
        \item \textbf{\texttt{Server Initiated}}: 技能由服务器发起，然后复制到所属的客户端上执行。
        \item \textbf{\texttt{Server Only}}: 技能只能在服务器上激活和执行，不会复制到客户端。
    \end{itemize}
    
    \item\dfntxt{Replication Policy}: 这是一个容易引起误解的设置。即使你希望技能是可复制的，也\textbf{不应修改此设置}，应保持默认的\il{Do Not Replicate}。技能的复制行为主要由\il{Net Execution Policy}控制。
    
    \item\dfntxt{Server Respects Remote Ability Cancellation}:默认勾选（\textcolor{red}{\faCheck}），表示如果你是客户端，并且本机（local）取消了技能，服务器会响应这个取消，你的技能会被取消。至于服务端永远可以取消客户端的技能。
    \item\dfntxt{Retrigger Instanced Ability}：“重新触发已实例化的技能” 是一个布尔选项，它决定了当你尝试激活一个已经在运行中的技能时会发生什么。具体来说：
    	\begin{itemize}
    	\item 启用:当你再次尝试激活一个当前正在运行的技能时，系统会先强制结束掉这个正在运行的技能实例，然后立刻重新激活它（即开始一个新的技能实例）。例如，假想一个需要持续引导的激光束技能。如果启用了这个选项，玩家在引导过程中再次按下技能键，激光束会中断并从头开始重新发射。
    	\item 未启用 (通常是默认值):当你尝试激活一个已经在运行的技能时，这次新的激活请求会被直接忽略，什么也不会发生。当前的技能会继续运行，直到它自己正常结束。
    	\end{itemize}
   总而言之，这个选项允许你决定一个正在运行的技能是否可以被它自身的下一次激活所“打断并重置”。
    
    
\end{description}

\subsection{简单示例}
本节创建了一个名为\texttt{GA\_Primary}的技能，其功能非常简单：
\begin{enumerate}
    \item 在\texttt{Event ActivateAbility}事件后连接一个\texttt{Print String}节点，用于在屏幕上打印调试信息，以确认技能已被激活。
    \item 在\texttt{Print String}节点后调用\texttt{EndAbility}节点，使技能在打印信息后立即结束。
\end{enumerate}
这个简单的技能为后续学习如何“赋予”和“激活”技能奠定了基础。


\section{赋予角色游戏技能 (Giving Gameplay Abilities)}
本节详细介绍了如何将一个创建好的游戏技能（Gameplay Ability）赋予给角色，这是激活技能的前提条件。

\subsection{核心概念}
\begin{itemize}
    \item \textbf{赋予技能的前提}: 一个角色（或任何拥有ASC的Actor）必须首先被“赋予”一个技能，然后才能激活它。直接尝试激活一个未被赋予的技能是无效的。
    \item \textbf{赋予技能的机制}: 通过调用技能系统组件（ASC）的 \texttt{GiveAbility()} 函数来实现。
    \item \textbf{\texttt{FGameplayAbilitySpec}}: \texttt{GiveAbility()} 函数需要的不是技能类本身，而是一个名为 \il{FGameplayAbilitySpec} 的结构体。这是一个轻量级的结构，包含了要赋予的技能的实例信息，例如：
    \begin{itemize}
        \item 技能的类 (\texttt{UGameplayAbility} 的子类)。
        \item 技能的等级 (Level)。
        \item 与技能绑定的输入ID (Input ID，一个旧版输入系统的概念)。
        \item 来源对象 (Source Object)。
    \end{itemize}
\end{itemize}

\subsection{在C++中实现赋予技能的逻辑}
在角色的基类 (\texttt{ACCBaseCharacter}) 中添加赋予技能的通用逻辑，以便玩家和未来的敌人类都可以复用。
\begin{enumerate}
    \item \textbf{创建技能数组}: 在 \texttt{ACCBaseCharacter.h} 中，定义一个 \texttt{TArray} 用于存储需要在游戏开始时赋予给角色的技能类。
\begin{amzcode}{cpp}
UPROPERTY(EditDefaultsOnly, Category = "Abilities")
TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;
\\end{amzcode}
    这个数组被标记为\texttt{EditDefaultsOnly}，意味着可以在角色的蓝图中方便地配置要赋予哪些技能。

    \item \textbf{创建赋予技能的函数}: 在 \texttt{ACCBaseCharacter} 中创建\il{protected} 函数 \texttt{GiveStartupAbilities()}。
    \begin{amzcode}{cpp}
void ACCBaseCharacter::GiveStartupAbilities()
{
	...
	FGameplayAbilitySpec AbilitySpec(AbilityClass);
	GetAbilitySystemComponent()->GiveAbility(AbilitySpec);
}
    \\end{amzcode}

    \item \textbf{选择正确的调用时机}: 赋予技能是一个\textbf{只应在服务器上执行一次}的操作。
    \begin{itemize}
        \item 在玩家角色类 (\texttt{ACCPlayerCharacter}) 的 \texttt{PossessedBy()} 函数中调用 \texttt{GiveStartupAbilities()}。
        \item \texttt{PossessedBy()} 是一个\textbf{仅在服务器上调用}的函数，它标志着角色已经被一个控制器所拥有，此时是初始化技能的理想时机。
        \item 通过增加一个 \texttt{HasAuthority()} 检查，可以确保该逻辑严格只在服务器上运行。
    \end{itemize}
\end{enumerate}

\subsection{在蓝图中配置和测试}
\begin{enumerate}
    \item \textbf{配置技能}: 在玩家角色的蓝图 (\texttt{BP\_CC\_PlayerCharacter})，找到 \texttt{StartupAbilities} 数组，并将之前创建的 \texttt{GA\_Primary} 技能蓝图添加进去。
    \item \textbf{蓝图快速测试}:
    \begin{itemize}
        \item 为了快速验证，在角色蓝图的事件图表中，将主输入事件 (\texttt{IA\_Primary}) 连接到了 \texttt{Try Activate Ability by Class} 节点。
        \item \texttt{Get Ability System Component} 蓝图节点 (来自 \texttt{AbilitySystemBlueprintLibrary}) 会自动利用 \texttt{IAbilitySystemInterface} 来获取ASC。
        \item 运行游戏并点击鼠标左键，可以看到屏幕上打印出 \texttt{GA\_Primary} 中设置的调试信息，证明技能被成功赋予并激活。
        \item 作为反向验证，如果从 \texttt{StartupAbilities} 数组中移除 \texttt{GA\_Primary}，再次运行游戏时点击将无任何反应，证明了“必须先赋予才能激活”的原则。
    \end{itemize}
\end{enumerate}

\subsection{后续步骤}
虽然蓝图测试很方便，但最终目标是在C++中处理技能激活。接下来的计划是在\texttt{PlayerController} 中，通过“游戏标签” (\texttt{Gameplay Tag}) 来激活技能，这是一种更灵活和推荐的做法。


\section{原生游戏标签 (Native Gameplay Tags)}
本节详细讲解了游戏标签（Gameplay Tags）的概念，并重点介绍了在C++中创建和管理“原生标签”的专业方法，这被认为是比在编辑器中创建标签更优越的实践。

\subsection{游戏标签 (Gameplay Tag) 简介}
\begin{itemize}
    \item \textbf{本质}: 游戏标签是一个轻量级的、层级化的命名标识（例如 \texttt{Character.Skill.Primary}），其在代码中的类型为 \texttt{FGameplayTag}。
    \item \textbf{创建方式}:
    \begin{enumerate}
        \item \textbf{编辑器创建}: 在项目设置中手动添加。优点是简单快捷，但缺点是容易因拼写错误导致bug，且在大型项目中难以维护。
        \item \textbf{C++原生创建}: 在代码中定义和注册标签。这是本节推荐的核心方法。
    \end{enumerate}
    \item \textbf{原生标签的优势}:
    \begin{itemize}
        \item \textbf{编译时安全}: 由于标签在C++中定义，任何拼写错误都会导致编译失败，从而在早期阶段就能发现问题。
        \item \textbf{集中管理}: 所有核心标签都集中在一个或多个C++文件中，便于查找、修改和维护。
        \item \textbf{高性能}: 原生标签在引擎启动时被加载，访问效率更高。
    \end{itemize}
\end{itemize}

\subsection{实现原生游戏标签的步骤}
\begin{enumerate}
    \item \textbf{创建标签管理器单例 (Singleton)}:
    \begin{itemize}
        \item 创建一个专门的C++类（如此处的 \texttt{FCCGameplayTags}）来统一管理项目的所有原生标签。
        \item 在该类中，为每一个需要的标签声明一个 \texttt{FGameplayTag} 成员变量。
        \item 实现单例模式，提供一个静态的 \texttt{Get()} 方法来全局访问该类的唯一实例。
    \end{itemize}
    \begin{amzcode}{cpp}
    // FCCGameplayTags.h
    class FCCGameplayTags
    {
    public:
        static const FCCGameplayTags& Get() { return GameplayTags; }
        static void InitializeNativeTags();

        FGameplayTag Attributes_Primary_Strength;
        // ... 其他标签
    private:
        static FCCGameplayTags GameplayTags;
    };
    \\end{amzcode}

    \item \textbf{注册原生标签}:
    \begin{itemize}
        \item 在该单例类的实现文件 (.cpp) 中，实现 \texttt{InitializeNativeTags} 函数。
        \item 使用 \texttt{UGameplayTagsManager::Get().AddNativeGameplayTag()} 或 \texttt{RequestGameplayTag()} 方法，通过字符串来创建标签，并将其赋值给之前声明的 \texttt{FGameplayTag} 变量。
    \end{itemize}
\begin{amzcode}{cpp}
// FCCGameplayTags.cpp
void FCCGameplayTags::InitializeNativeTags()
{
	GameplayTags.Attributes_Primary_Strength = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Attributes.Primary.Strength"),
  	FString("Primary attribute for physical damage")
  );
	// ... 注册其他标签
}
    \\end{amzcode}

    \item \textbf{配置项目以加载原生标签}:
    \begin{itemize}
        \item 这是至关重要的一步。引擎需要在启动时知道去哪里加载这些在C++中定义的标签。
        \item 打开项目的配置文件 \texttt{Config/DefaultGame.ini}。
        \item 在 \texttt{[/Script/GameplayTags.GameplayTagsSettings]} 配置节下，添加一行指向你的标签单例类的路径。
    \end{itemize}
    \begin{amzcode}{cpp}
    [/Script/GameplayTags.GameplayTagsSettings]
    +GameplayTagList=(Path="/Script/YourProjectName.FCCGameplayTags")
    \\end{amzcode}
    
    \item \textbf{在模块启动时调用初始化}: 在你的游戏模块的主C++文件中（例如 \texttt{YourProject.cpp}），重写 \texttt{StartupModule()} 函数，并在其中调用标签单例的 \texttt{InitializeNativeTags()} 函数。
    
    \item \textbf{在技能蓝图中使用标签}:
    \begin{itemize}
        \item 编译代码并重启编辑器后，新创建的原生标签就会出现在编辑器的标签选择器中。
        \item 打开之前创建的 \texttt{GA\_Primary} 技能蓝图，在“类默认值”的“Tags”部分，找到 \texttt{Ability Tags} 属性。
        \item 将刚刚创建的原生标签（例如 \texttt{InputTag.Primary}）赋予给这个技能。这个标签成为了该技能的唯一标识。
    \end{itemize}
\end{enumerate}

\subsection{总结}
通过以上步骤，我们成功地创建了一个原生游戏标签，并将其与一个具体的技能关联起来。这为后续通过标签来准确、高效地激活特定技能奠定了坚实的基础。


\section{通过标签激活技能}
本节核心内容是从上一节课中“按类激活技能”的测试方法，过渡到更为专业和灵活的“按游戏标签激活技能”的正式方法。这一转变将输入逻辑从角色蓝图转移到了C++的玩家控制器中。

\subsection{问题：按类激活的局限性}
在蓝图中直接使用\mybox{Try Activate Ability by Class}节点来激活一个特定的技能类，存在明显的缺点：
\begin{itemize}
    \item \textbf{紧密耦合}: 输入操作（如鼠标左键点击）与一个具体的技能类（如\texttt{GA\_Primary}）被硬编码在一起。
    \item \textbf{缺乏灵活性}: 如果想让鼠标左键触发另一个不同的技能，就必须去修改蓝图或C++代码，这在项目中非常不便。
\end{itemize}

\subsection{解决方案：按标签激活的优势}
更优越的方法是让输入操作与一个通用的“输入标签”（Input Tag）关联，而不是一个具体的技能。
\begin{itemize}
    \item \textbf{解耦}: 输入代码只负责广播一个\dfntxt{意图}，例如“玩家按下了主要攻击键”，这个意图由一个输入标签（如\texttt{InputTag.Primary}）来代表。
    \item \textbf{高度灵活}: 任何被赋予给角色、并且拥有\texttt{InputTag.Primary}这个标签的技能，都可以响应这个输入。更换主要攻击技能时，只需修改技能蓝图中的标签，而无需改动任何输入代码。
\end{itemize}

\subsection{C++ 实现步骤}
\begin{enumerate}
    \item \textbf{将输入逻辑移至玩家控制器 (Player Controller)}:
    \begin{itemize}
        \item 玩家控制器是处理玩家输入的最合适场所。打开\texttt{ACCPlayerController}类。
    \end{itemize}

    \item \textbf{创建接口以获取ASC}:
    \begin{itemize}
        \item 玩家控制器需要一种通用的方式来获取其所控制的Pawn身上的技能系统组件（ASC），而不想知道Pawn的具体类型。
        \item 为此，创建了一个新的C++接口，名为\texttt{ICombatInterface}。
        \item 在此接口中，定义了一个纯虚函数\texttt{GetAbilitySystemComponent()}。
        \item 让玩家角色类\texttt{ACCPlayerCharacter}继承并实现这个新接口。现在，控制器可以通过接口指针安全地调用\texttt{GetAbilitySystemComponent()}，而无需进行类型转换。
    \end{itemize}

    \item \textbf{实现输入处理函数}:
    \begin{itemize}
        \item 在\texttt{ACCPlayerController}中，为主要输入动作创建了处理函数，例如\texttt{PrimaryInputPressed()}。
        \item 在此函数中，通过接口获取ASC，然后调用\texttt{ASC->TryActivateAbilitiesByTag()}，并传入之前定义好的原生输入标签（\texttt{InputTag.Primary}）。
    \end{itemize}
    \begin{amzcode}{cpp}
    void ACCPlayerController::PrimaryInputPressed()
    {
        // 获取ASC
        ICombatInterface* CombatInterface = Cast<ICombatInterface>(GetPawn());
        if (CombatInterface)
        {
            // 通过标签激活技能
            CombatInterface->GetAbilitySystemComponent()->TryActivateAbilitiesByTag(
                FCCGameplayTags::Get().InputTag_Primary
            );
        }
    }
    \end{amzcode}

    \item \textbf{绑定增强输入 (Enhanced Input)}:
    \begin{itemize}
        \item 在\texttt{ACCPlayerController}的\texttt{SetupInputComponent()}函数中，获取增强输入子系统。
        \item 将输入资产（\texttt{IA\_Primary}）的\texttt{Triggered}事件绑定到刚刚创建的\texttt{PrimaryInputPressed()}函数上。
    \end{itemize}

    \item \textbf{清理蓝图}:
    \begin{itemize}
        \item 最后，回到玩家角色蓝图(\texttt{BP\_CCPlayerCharacter})中，删除之前用于测试的、连接在\texttt{IA\_Primary}输入事件后面的所有蓝图节点。
        \item 现在所有的输入到技能激活的流程都已在C++中清晰地建立起来。
    \end{itemize}
\end{enumerate}

\subsection{总结}
通过本节课的操作，项目建立了一个健壮且可扩展的输入到技能激活的系统。玩家的输入现在被抽象成一个“标签意图”，由C++控制器广播，任何匹配该标签的技能都可以被激活，实现了逻辑的高度解耦。

\section{添加次要和第三技能}
本节字幕在前一节课的基础上，演示了如何扩展输入系统和技能系统，为角色添加更多的技能，即次要技能（Secondary Ability）和第三技能（Tertiary Ability），并将它们分别绑定到鼠标右键和键盘按键上。

\subsection{扩展原生游戏标签}
为了标识新的输入动作，首先需要在C++中定义新的原生游戏标签。
\begin{enumerate}
    \item 在标签管理器类 \texttt{FCCGameplayTags} 中，添加新的 \texttt{FGameplayTag} 成员变量。
    \begin{amzcode}{cpp}
    FGameplayTag InputTag_Secondary;
    FGameplayTag InputTag_Tertiary;
    \end{amzcode}
    \item 在 \texttt{InitializeNativeTags} 函数中，为这些新标签赋值，并添加描述。
    \begin{amzcode}{cpp}
    GameplayTags.InputTag_Secondary = UGameplayTagsManager::Get().AddNativeGameplayTag(
        FName("InputTag.Secondary"), FString("Input for Secondary Ability")
    );
    GameplayTags.InputTag_Tertiary = UGameplayTagsManager::Get().AddNativeGameplayTag(
        FName("InputTag.Tertiary"), FString("Input for Tertiary Ability")
    );
    \end{amzcode}
\end{enumerate}

\subsection{在编辑器中配置增强输入}
接下来，在虚幻引擎编辑器中创建新的输入动作并将其映射到具体的物理按键。
\begin{enumerate}
    \item \textbf{创建输入动作 (Input Actions)}:
    \begin{itemize}
        \item 在内容浏览器中，创建两个新的输入动作资源：\texttt{IA\_Secondary} 和 \texttt{IA\_Tertiary}。
    \end{itemize}
    \item \textbf{更新输入映射上下文 (Input Mapping Context)}:
    \begin{itemize}
        \item 打开项目的输入映射上下文资源 (\texttt{IMC\_Default})。
        \item 添加新的映射关系：
        \begin{itemize}
            \item 将 \texttt{IA\_Secondary} 映射到“鼠标右键” (Right Mouse Button)。
            \item 将 \texttt{IA\_Tertiary} 映射到键盘“1”键。
        \end{itemize}
    \end{itemize}
\end{enumerate}

\subsection{扩展玩家控制器的C++代码}
在 \texttt{ACCPlayerController} 中添加处理新输入的逻辑。
\begin{enumerate}
    \item \textbf{添加输入处理函数}:
    \begin{itemize}
        \item 声明并定义新的函数来处理次要和第三输入的按下事件：\il{SecondaryInputPressed()} 和 \il{TertiaryInputPressed()}。
        \item 这些函数的实现逻辑与 \il{PrimaryInputPressed()} 完全相同，只是它们在调用 \il{TryActivateAbilitiesByTag()} 时传入了各自对应的输入标签（\il{InputTag.Secondary} 和 \il{InputTag.Tertiary}）。
    \end{itemize}
    \item \textbf{绑定输入动作}:
    \begin{itemize}
        \item 在 \texttt{SetupInputComponent()} 函数中，将新创建的输入动作资源 (\texttt{IA\_Secondary} 和 \texttt{IA\_Tertiary}) 的 \texttt{Triggered} 事件分别绑定到 \texttt{SecondaryInputPressed()} 和 \texttt{TertiaryInputPressed()} 函数上。
    \end{itemize}
\end{enumerate}

\subsection{创建并配置新技能}
最后，创建新的技能蓝图，并将它们赋予角色。
\begin{enumerate}
    \item \textbf{创建技能蓝图}:
    \begin{itemize}
        \item 复制现有的 \texttt{GA\_Primary} 技能蓝图，创建出 \texttt{GA\_Secondary} 和 \texttt{GA\_Tertiary}。
        \item 修改这两个新技能蓝图内部的 \texttt{Print String} 节点，使其打印各自的名称，以便于调试时区分。
    \end{itemize}
    \item \textbf{分配输入标签}:
    \begin{itemize}
        \item 打开 \texttt{GA\_Secondary} 的类默认值，将其 \texttt{Ability Tags} 设置为 \texttt{InputTag.Secondary}。
        \item 打开 \texttt{GA\_Tertiary} 的类默认值，将其 \texttt{Ability Tags} 设置为 \texttt{InputTag.Tertiary}。
    \end{itemize}
    \item \textbf{赋予技能给角色}:
    \begin{itemize}
        \item 打开玩家角色蓝图 \texttt{BP\_CCPlayerCharacter}。
        \item 在其 \texttt{StartupAbilities} 数组中，添加 \texttt{GA\_Secondary} 和 \texttt{GA\_Tertiary}。
    \end{itemize}
\end{enumerate}

\subsection{测试与验证}
完成以上所有步骤并编译代码后，运行游戏。现在，点击鼠标左键、右键和键盘“1”键，应该会分别在屏幕上看到“Primary activated”、“Secondary activated”和“Tertiary activated”的打印信息，证明整个系统已成功扩展。



\section{创建技能基类}
本节字幕旨在解决之前课程中出现的代码重复问题。通过创建一个自定义的C++技能基类，可以将所有技能共享的通用逻辑和属性集中管理，从而优化项目结构，提高可维护性。

\subsection{问题：重复的蓝图逻辑}
\begin{itemize}
    \item 在之前的课程中，我们创建了多个技能蓝图（\texttt{GA\_Primary}, \texttt{GA\_Secondary}等）。
    \item 这些蓝图都包含了相似的逻辑，例如用于调试的\texttt{Print String}节点。
    \item 如果需要修改这个调试逻辑（例如，增加一个开关来控制是否打印），就必须手动修改每一个技能蓝图，这非常低效且容易出错。
\end{itemize}

\subsection{解决方案：创建C++技能基类}
为了解决上述问题，我们创建一个新的C++类 \texttt{UCCGameplayAbility}，它继承自虚幻引擎的 \texttt{UGameplayAbility}。这个新类将作为我们项目中所有技能蓝图的父类。
\begin{itemize}
    \item \textbf{代码复用}: 所有通用的功能（如调试信息打印）都可以在这个C++基类中实现一次。
    \item \textbf{集中管理}: 通用的属性（如输入标签）可以在基类中定义，方便统一配置。
    \item \textbf{蓝图友好}: 可以将C++属性和函数暴露给蓝图，让设计师可以在编辑器中方便地进行配置，而无需修改代码。
\end{itemize}

\subsection{C++ 实现步骤}
\begin{enumerate}
    \item \textbf{创建新C++类}:
    \begin{itemize}
        \item 在C++类向导中，创建一个名为 \texttt{UCCGameplayAbility} 的新类，并使其继承自 \texttt{UGameplayAbility}。
    \end{itemize}
    \item \textbf{设为抽象类 (Abstract)}:
    \begin{itemize}
        \item 在 \texttt{UCLASS} 宏中添加 \texttt{Abstract} 关键字。
        \item 这可以防止设计师在编辑器中直接创建 \texttt{UCCGameplayAbility} 的蓝图实例，强制他们必须创建其子蓝图，确保了类的正确使用。
    \end{itemize}
    \begin{amzcode}{cpp}
    UCLASS(Abstract)
    class YOURPROJECT_API UCCGameplayAbility : public UGameplayAbility
    \end{amzcode}
    \item \textbf{添加通用属性}:
    \begin{itemize}
        \item 在 \texttt{UCCGameplayAbility.h} 中，添加一个新的 \texttt{FGameplayTag} 属性，专门用于存储与该技能关联的输入标签。
    \end{itemize}
    \begin{amzcode}{cpp}
    UPROPERTY(EditDefaultsOnly, Category = "Input")
    FGameplayTag StartupInputTag;
    \end{amzcode}
    \item \textbf{移除对旧接口的依赖}:
    \begin{itemize}
        \item 字幕中还提到了一个细节：由于现在所有的输入逻辑都在玩家控制器中处理，角色类不再需要实现之前创建的\texttt{ICombatInterface}接口来暴露ASC，因此可以将其移除，以简化代码。
    \end{itemize}
\end{enumerate}

\subsection{蓝图重设父类与配置}
在C++代码完成后，需要在编辑器中更新现有的技能蓝图。
\begin{enumerate}
    \item \textbf{重设父类 (Reparent Blueprint)}:
    \begin{itemize}
        \item 打开每一个技能蓝图（\texttt{GA\_Primary}, \texttt{GA\_Secondary} 等）。
        \item 在“类设置”中，将其“父类”从 \texttt{GameplayAbility} 修改为我们新创建的 \texttt{UCCGameplayAbility}。
    \end{itemize}
    \item \textbf{更新标签配置}:
    \begin{itemize}
        \item 重设父类后，在技能蓝图的“类默认值”中，会看到新的 \texttt{StartupInputTag} 属性。
        \item \textbf{清理旧标签}: 从 \texttt{Ability Tags} 容器中移除之前添加的输入标签（如 \texttt{InputTag.Primary}）。
        \item \textbf{设置新属性}: 为每个技能蓝图的 \texttt{StartupInputTag} 属性选择其对应的输入标签。
    \end{itemize}
    \item \textbf{移除重复的蓝图节点}:
    \begin{itemize}
        \item 删除每个技能蓝图事件图表中的 \texttt{Print String} 节点，因为这个功能未来将在C++基类中统一实现。
    \end{itemize}
\end{enumerate}

\subsection{总结}
通过创建并使用一个自定义的技能基类，我们成功地重构了技能系统，消除了代码冗余，并为未来添加更多通用功能（如消耗、冷却、UI信息等）打下了坚实、可扩展的基础。

\section{播放蒙太奇并等待}
本节介绍了一个在游戏能力系统（GAS）中至关重要的概念：技能任务（Ability Tasks），并以最常用的任务之一——\texttt{Play Montage and Wait}为例，详细演示了如何在技能中播放动画。

\subsection{技能任务 (Ability Task) 简介}
\begin{itemize}
    \item \textbf{本质}: 技能任务是可以在技能内部执行的异步操作。它们允许一个技能在等待某个事件（如动画播放完毕、延迟结束、玩家输入等）发生时保持激活状态，而不会阻塞游戏线程。
    \item \textbf{异步性}: 当一个技能任务启动时，它会立即返回，但技能本身并不会结束。任务会在后台运行，并在完成或被中断时，通过其输出执行引脚来触发后续逻辑。
    \item \textbf{关键作用}: 技能任务是实现复杂技能逻辑（如持续施法、多段攻击、等待动画同步等）的核心工具。
\end{itemize}

\subsection{详解 `Play Montage and Wait` 任务}
这是GAS内置的一个强大的技能任务，专门用于播放动画蒙太奇（Animation Montage）。
\begin{itemize}
    \item \textbf{功能}: 它指示角色的动画实例播放一个指定的蒙太奇，并“等待”其结束。
    \item \textbf{输出执行引脚}: 该任务节点有多个输出引脚，分别对应蒙太奇播放的不同结束状态：
    \begin{itemize}
        \item \textbf{\texttt{On Completed}}: 蒙太奇从头到尾正常播放完毕。
        \item \textbf{\texttt{On Blend Out}}: 蒙太奇开始淡出。
        \item \textbf{\texttt{On Interrupted}}: 蒙太奇被另一个更高优先级的蒙太奇打断。
        \item \textbf{\texttt{On Cancelled}}: 拥有该任务的技能本身被取消，从而导致蒙太奇播放也被取消。
    \end{itemize}
    \item \textbf{正确的技能结束时机}: 必须在这些输出引脚之一被触发后，才调用\texttt{End Ability}节点来结束技能。如果在启动任务后立即结束技能，动画将不会播放，因为技能的生命周期已经结束。
\end{itemize}

\subsection{实现步骤}
\begin{enumerate}
    \item \textbf{创建动画蒙太奇 (Animation Montage)}:
    \begin{itemize}
        \item 在内容浏览器中，找到一个攻击动画序列（Animation Sequence）。
        \item 右键点击该序列，选择“创建” -> “创建动画蒙太奇”。
        \item 打开新创建的蒙太奇资源，可以在其中定义不同的片段（Sections），用于播放动画的不同部分。
    \end{itemize}
    \item \textbf{配置动画蓝图 (Animation Blueprint)}:
    \begin{itemize}
        \item 确保角色的动画蓝图的动画图表中有一个\texttt{Slot 'DefaultSlot'}节点。
        \item 这个插槽节点是动画蒙太奇播放的“通道”。没有它，蒙太奇将无法播放。
    \end{itemize}
    \item \textbf{在技能蓝图中实现逻辑}:
    \begin{itemize}
        \item 打开主要攻击技能蓝图 \texttt{GA\_Primary}。
        \item 在事件图表中，从\texttt{Event ActivateAbility}引脚拉出，搜索并创建\texttt{Play Montage and Wait}任务节点。
        \item 将之前创建的攻击动画蒙太奇资源赋给该节点的\texttt{Montage to Play}属性。
        \item 将该任务的所有输出执行引脚（\texttt{On Completed}, \texttt{On Interrupted}等）都连接到一个\texttt{End Ability}节点上。这确保了无论动画以何种方式结束，技能最终都会被正确地清理和终止。
    \end{itemize}
\end{enumerate}

\subsection{总结}
通过使用\texttt{Play Montage and Wait}技能任务，我们成功地将一个攻击动画与主要攻击技能绑定在了一起。这不仅实现了视觉表现，更重要的是，它引入了异步技能任务的概念，为构建更复杂、更具动态性的技能系统铺平了道路。现在，当玩家按下主要攻击键时，角色会播放攻击动画，并且技能会一直保持激活状态，直到动画播放完成或被中断。
\end{document}
